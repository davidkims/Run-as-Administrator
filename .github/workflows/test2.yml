name: "🐧 Linux/RHEL Image Suite (ALL-IN-ONE: Dirs + ISO Download/Create + QCOW2 + Release)"

on:
  workflow_dispatch:
    inputs:
      distro:
        description: "배포판 (ubuntu|debian|rocky|alma|rhel)"
        type: choice
        required: true
        default: "ubuntu"
        options: [ "ubuntu", "debian", "rocky", "alma", "rhel" ]
      qcow_size_gb:
        description: "QCOW2 사이즈(GB)"
        required: true
        default: "8"
      release_tag:
        description: "Release 태그(비우면 auto-{run_id})"
        required: false
        default: ""
  workflow_call:
    inputs:
      distro: { type: string, required: true }
      qcow_size_gb: { type: string, default: "8" }
      release_tag: { type: string, default: "" }

permissions:
  contents: write

concurrency:
  group: linux-rhel-image-suite-${{ github.ref }}
  cancel-in-progress: false

jobs:
  image-suite:
    name: "Build/Pack: Dirs + ISO DL/Create + QCOW2 + Artifacts + Release"
    runs-on: ubuntu-latest
    env:
      ECHO_ROOT: .github/echo_linux
      DIST_DIR: dist
      ISO_DIR: dist/isos
      IMG_DIR: dist/images
      LOG_DIR: dist/logs
      META_DIR: dist/meta

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Init dirs
        run: |
          set -Eeuo pipefail
          mkdir -p "$ECHO_ROOT"/{linux,rhel}/bulk \
                   "$DIST_DIR" "$ISO_DIR" "$IMG_DIR" "$LOG_DIR" "$META_DIR"
          printf '[%s] INIT: dirs ready\n' "$(date -u +'%F %T')"

      - name: Echo tools (functions)
        id: echo-tools
        shell: bash
        run: |
          set -Eeuo pipefail
          cat > "$ECHO_ROOT/echo_tools.sh" <<'EOS'
          set -Eeuo pipefail
          TS(){ date -u +'%Y-%m-%dT%H:%M:%SZ'; }
          echoe(){ printf '[%s] %s\n' "$(TS)" "$*"; }
          fail(){ echoe "::error::$*"; exit 1; }

          ensure_cmd(){
            local cmd="$1"
            if ! command -v "$cmd" >/dev/null 2>&1; then
              echoe "installing: $cmd"
              sudo apt-get update -y
              case "$cmd" in
                mkisofs) sudo apt-get install -y genisoimage ;;
                xorriso) sudo apt-get install -y xorriso ;;
                qemu-img) sudo apt-get install -y qemu-utils ;;
                curl|jq) sudo apt-get install -y curl jq ;;
                sha256sum|sha512sum) sudo apt-get install -y coreutils ;;
                file) sudo apt-get install -y file ;;
                *) sudo apt-get install -y "$cmd" || true ;;
              esac
            fi
          }

          parse_dir_spec(){
            local spec="$1"; local out="$2"
            : > "$out"
            IFS=',' read -ra items <<< "$spec"
            for it in "${items[@]}"; do
              local name="${it%%:*}"; local cnt="${it##*:}"
              [[ -z "$name" || -z "$cnt" ]] && continue
              printf '%s %s\n' "$name" "$cnt" >> "$out"
            done
          }

          # 디렉토리 인지형 체크섬 검증 (이전 'No such file or directory' 문제 해결)
          verify_sum(){
            local fpath="$1"      # full path to ISO
            local stype="$2"      # sha256|sha512
            local expected="$3"   # embedded expected hash (optional)
            local sum_url="$4"    # checksum list URL (optional)

            local dir base
            dir="$(dirname "$fpath")"
            base="$(basename "$fpath")"

            # 1) 임베디드 기대값으로 검증
            if [[ -n "$expected" ]]; then
              echoe "Verifying ($stype) with embedded expected hash in dir: $dir"
              if [[ "$stype" = "sha512" ]]; then
                ( cd "$dir" && printf "%s  %s\n" "$expected" "$base" | sha512sum -c - )
              else
                ( cd "$dir" && printf "%s  %s\n" "$expected" "$base" | sha256sum -c - )
              fi
              return
            fi

            # 2) 원격 목록 기반 검증
            if [[ -n "$sum_url" ]]; then
              echoe "Fetching checksum list: $sum_url"
              local list_path="$dir/${base}.${stype}.list"
              curl -fsSL "$sum_url" -o "$list_path" || { echoe "WARN: checksum fetch failed"; return; }
              if [[ "$stype" = "sha512" ]]; then
                ( cd "$dir" && grep -E "  ${base}\$" "$(basename "$list_path")" | sha512sum -c - ) \
                  || echoe "WARN: checksum mismatch or entry not found"
              else
                ( cd "$dir" && grep -E "  ${base}\$" "$(basename "$list_path")" | sha256sum -c - ) \
                  || echoe "WARN: checksum mismatch or entry not found"
              fi
              return
            fi

            # 3) 소스가 없으면 로컬 해시만 출력
            echoe "No checksum source provided; computing local $stype only"
            if [[ "$stype" = "sha512" ]]; then
              ( cd "$dir" && sha512sum "$base" | tee "${base}.sha512.txt" )
            else
              ( cd "$dir" && sha256sum "$base" | tee "${base}.sha256.txt" )
            fi
          }

          # 배포판별 공식 ISO 주소 및 체크섬 정보
          # - URL과 체크섬 주소를 '자동으로' 보여주고 meta로 저장
          set_official_iso_vars(){
            local d="$1"
            case "$d" in
              ubuntu)
                ISO_URL="https://releases.ubuntu.com/24.04.3/ubuntu-24.04.3-live-server-amd64.iso"
                FILE_NAME="ubuntu-24.04.3-live-server-amd64.iso"
                SUM_TYPE="sha256"
                SUM_URL="https://releases.ubuntu.com/24.04.3/SHA256SUMS"
                ;;
              debian)
                ISO_URL="https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/debian-13.1.0-amd64-netinst.iso"
                FILE_NAME="debian-13.1.0-amd64-netinst.iso"
                SUM_TYPE="sha512"
                SUM_URL="https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/SHA512SUMS"
                ;;
              rocky)
                ISO_URL="https://download.rockylinux.org/pub/rocky/9/isos/x86_64/Rocky-9-latest-x86_64-minimal.iso"
                FILE_NAME="Rocky-9-latest-x86_64-minimal.iso"
                SUM_TYPE="sha256"
                SUM_URL="https://download.rockylinux.org/pub/rocky/9/isos/x86_64/CHECKSUM"
                ;;
              alma)
                ISO_URL="https://repo.almalinux.org/almalinux/9/isos/x86_64/AlmaLinux-9-latest-x86_64-minimal.iso"
                FILE_NAME="AlmaLinux-9-latest-x86_64-minimal.iso"
                SUM_TYPE="sha256"
                SUM_URL="https://repo.almalinux.org/almalinux/9/isos/x86_64/CHECKSUM"
                ;;
              rhel)
                # RHEL은 인증 필요 → 자동으로 AlmaLinux로 대체
                ISO_URL="https://repo.almalinux.org/almalinux/9/isos/x86_64/AlmaLinux-9-latest-x86_64-minimal.iso"
                FILE_NAME="AlmaLinux-9-latest-x86_64-minimal.iso"
                SUM_TYPE="sha256"
                SUM_URL="https://repo.almalinux.org/almalinux/9/isos/x86_64/CHECKSUM"
                FALLBACK_NOTE="Requested 'rhel' but used AlmaLinux official ISO due to auth requirement."
                ;;
              *)
                ISO_URL=""; FILE_NAME=""
                ;;
            esac
          }
          EOS
          chmod +x "$ECHO_ROOT/echo_tools.sh"

      - name: Generate bulk directories/files (mandatory)
        shell: bash
        run: |
          set -Eeuo pipefail
          source "$ECHO_ROOT/echo_tools.sh"
          # 고정 스펙(“모든 과정 필수”)—원하시면 아래 값 조정 가능
          SPEC_FILE="$META_DIR/dir_spec.txt"
          echo "linux:100,rhel:100" > "$SPEC_FILE"
          while read -r PREFIX COUNT; do
            echoe "Generating prefix=$PREFIX count=$COUNT"
            BASE="$ECHO_ROOT/$PREFIX/bulk"
            for ((i=1;i<=COUNT;i++)); do
              D="$BASE/${PREFIX}_dir_$i"
              mkdir -p "$D/sub1" "$D/sub2"
              echo "sample file for $PREFIX #$i" > "$D/README.txt"
              printf '{"prefix":"%s","index":%d,"ts":"%s"}\n' "$PREFIX" "$i" "$(date -u +'%F %T')" > "$D/meta.json"
            done
          done < "$SPEC_FILE"
          tar -C "$ECHO_ROOT" -cf "$DIST_DIR/echo_bulk.tar" .
          echoe "Bulk generated -> $DIST_DIR/echo_bulk.tar"

      - name: Download official base ISO (mandatory; show URLs)
        shell: bash
        run: |
          set -Eeuo pipefail
          source "$ECHO_ROOT/echo_tools.sh"
          ensure_cmd curl; ensure_cmd sha256sum; ensure_cmd sha512sum; ensure_cmd file; ensure_cmd jq
          D="${{ inputs.distro || github.event.inputs.distro }}"
          set_official_iso_vars "$D"

          [[ -z "$ISO_URL" ]] && fail "No ISO URL resolved"

          # 주소 자동 표시 + 메타 저장
          echoe "Base ISO URL: $ISO_URL"
          echoe "Checksum List: ${SUM_URL:-none} (${SUM_TYPE:-sha256})"
          jq -n --arg url "$ISO_URL" --arg sumurl "${SUM_URL:-}" --arg sumtype "${SUM_TYPE:-sha256}" --arg note "${FALLBACK_NOTE:-}" \
            '{base_iso_url:$url, checksum_url:$sumurl, checksum_type:$sumtype, note:$note}' \
            | tee "$META_DIR/base_iso.urls.json"

          OUT="$ISO_DIR/$FILE_NAME"
          echoe "Downloading -> $OUT"
          curl -fL "$ISO_URL" -o "$OUT"
          file "$OUT" | tee "$META_DIR/base_iso.file.txt"

          # 체크섬 검증(가능하면): 실패해도 경고로만 처리(미러 상태 대비)
          verify_sum "$OUT" "${SUM_TYPE:-sha256}" "" "${SUM_URL:-}"

      - name: Create custom ISO (mandatory)
        shell: bash
        run: |
          set -Eeuo pipefail
          source "$ECHO_ROOT/echo_tools.sh"
          if ! command -v mkisofs >/dev/null 2>&1; then ensure_cmd mkisofs || true; fi
          if ! command -v mkisofs >/dev/null 2>&1 && ! command -v xorriso >/dev/null 2>&1; then ensure_cmd xorriso; fi
          SRC="$ECHO_ROOT"
          LABEL="ECHO_${{ inputs.distro || github.event.inputs.distro }}_$(date -u +%Y%m%d)"
          ISO_OUT="$ISO_DIR/custom_${{ inputs.distro || github.event.inputs.distro }}.iso"
          if command -v mkisofs >/dev/null 2>&1; then
            mkisofs -V "$LABEL" -J -R -o "$ISO_OUT" "$SRC" 2>&1 | tee "$LOG_DIR/mkisofs.log"
          else
            xorriso -as mkisofs -V "$LABEL" -J -R -o "$ISO_OUT" "$SRC" 2>&1 | tee "$LOG_DIR/xorriso.log"
          fi
          sha256sum "$ISO_OUT" | tee "$META_DIR/custom_iso.sha256.txt"
          printf '{"label":"%s","path":"%s","ts":"%s"}\n' "$LABEL" "$ISO_OUT" "$(date -u +'%F %T')" > "$META_DIR/custom_iso.json"

      - name: Create QCOW2 base & snapshot (mandatory; fixed backing)
        shell: bash
        run: |
          set -Eeuo pipefail
          source "$ECHO_ROOT/echo_tools.sh"
          ensure_cmd qemu-img
          SIZE_GB="${{ inputs.qcow_size_gb || github.event.inputs.qcow_size_gb }}"
          DISTRO="${{ inputs.distro || github.event.inputs.distro }}"
          mkdir -p "$IMG_DIR"
          cd "$IMG_DIR"
          BASE="base_${DISTRO}.qcow2"
          SNAP="snap_${DISTRO}.qcow2"
          echoe "Creating base QCOW2: $BASE (${SIZE_GB}G)"
          qemu-img create -f qcow2 -o cluster_size=65536,compression_type=zlib "$BASE" "${SIZE_GB}G"
          qemu-img info --output=json "$BASE" | tee "$META_DIR/qcow2_base.info.json"
          qemu-img check "$BASE" | tee "$LOG_DIR/qcow2_base.check.log" || echoe "WARN: qemu-img check returned non-zero"
          echoe "Creating snapshot with proper relative backing"
          qemu-img create -f qcow2 -b "$BASE" -F qcow2 "$SNAP"
          qemu-img info --output=json "$SNAP" | tee "$META_DIR/qcow2_snap.info.json"
          qemu-img check "$SNAP" | tee "$LOG_DIR/qcow2_snap.check.log" || echoe "WARN: qemu-img check returned non-zero"

      - name: Upload artifacts (mandatory)
        uses: actions/upload-artifact@v4
        with:
          name: linux-rhel-image-suite-${{ github.run_id }}
          path: |
            dist/**
          if-no-files-found: error
          retention-days: 7

      - name: Create GitHub Release (mandatory)
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ inputs.release_tag && inputs.release_tag != '' && inputs.release_tag || format('auto-{0}', github.run_id) }}
          name: "Linux/RHEL Image Suite • ${{ inputs.distro || github.event.inputs.distro }}"
          body: |
            Automated ALL-IN-ONE image suite.
            - Distro: `${{ inputs.distro || github.event.inputs.distro }}`
            - Base ISO URL: (see dist/meta/base_iso.urls.json)
            - Custom ISO: `dist/isos/custom_${{ inputs.distro || github.event.inputs.distro }}.iso`
            - QCOW2: `dist/images/base_${{ inputs.distro || github.event.inputs.distro }}.qcow2` + `snap_${{ inputs.distro || github.event.inputs.distro }}.qcow2`
          files: |
            dist/isos/*.iso
            dist/images/*.qcow2
            dist/meta/**
            dist/logs/**
            dist/echo_bulk.tar
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
