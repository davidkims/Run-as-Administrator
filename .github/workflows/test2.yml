name: "🐧 Linux/RHEL Image Suite (ALL-IN-ONE + GPG + Bootable Installer ISO + Cloud-Init/Kickstart/Preseed + SBOM + GHCR + Hash Index)"

on:
  workflow_dispatch:
    inputs:
      distro:
        description: "배포판 (ubuntu|debian|rocky|alma|rhel)"
        type: choice
        required: true
        default: "ubuntu"
        options: [ "ubuntu", "debian", "rocky", "alma", "rhel" ]
      qcow_size_gb:
        description: "QCOW2 사이즈(GB)"
        required: true
        default: "8"
      release_tag:
        description: "Release 태그(비우면 auto-{run_id})"
        required: false
        default: ""
  workflow_call:
    inputs:
      distro: { type: string, required: true }
      qcow_size_gb: { type: string, default: "8" }
      release_tag: { type: string, default: "" }

permissions:
  contents: write
  packages: write

concurrency:
  group: linux-rhel-image-suite-${{ github.ref }}
  cancel-in-progress: false

jobs:
  image-suite:
    name: "ALL-IN-ONE build: Dirs + ISO DL/Create + GPG verify + Bootable Installer ISO + QCOW2 + SBOM + GHCR + Release"
    runs-on: ubuntu-latest
    env:
      ECHO_ROOT: .github/echo_linux
      DIST_DIR: dist
      ISO_DIR: dist/isos
      IMG_DIR: dist/images
      LOG_DIR: dist/logs
      META_DIR: dist/meta
      SEED_DIR: dist/seed
      WORK_DIR: dist/work
      GHCR_BASE: ghcr.io/${{ github.repository }}/image-suite

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Init dirs
        run: |
          set -Eeuo pipefail
          mkdir -p "$ECHO_ROOT"/{linux,rhel}/bulk \
                   "$DIST_DIR" "$ISO_DIR" "$IMG_DIR" "$LOG_DIR" "$META_DIR" \
                   "$SEED_DIR"/{cloud-init,preseed,kickstart} "$WORK_DIR"
          printf '[%s] INIT: dirs ready\n' "$(date -u +'%F %T')"

      - name: Echo tools (functions)
        id: echo-tools
        shell: bash
        run: |
          set -Eeuo pipefail
          cat > "$ECHO_ROOT/echo_tools.sh" <<'EOS'
          set -Eeuo pipefail
          TS(){ date -u +'%Y-%m-%dT%H:%M:%SZ'; }
          echoe(){ printf '[%s] %s\n' "$(TS)" "$*"; }
          fail(){ echoe "::error::$*"; exit 1; }

          ensure_cmd(){
            local cmd="$1"
            if ! command -v "$cmd" >/dev/null 2>&1; then
              echoe "installing: $cmd"
              sudo apt-get update -y
              case "$cmd" in
                mkisofs) sudo apt-get install -y genisoimage ;;
                xorriso) sudo apt-get install -y xorriso ;;
                isohybrid|isohdpfx.bin) sudo apt-get install -y syslinux-utils isolinux || true ;;
                qemu-img) sudo apt-get install -y qemu-utils ;;
                curl|jq) sudo apt-get install -y curl jq ;;
                sha256sum|sha512sum) sudo apt-get install -y coreutils ;;
                file) sudo apt-get install -y file ;;
                gpg|gpgv|dirmngr) sudo apt-get install -y gnupg dirmngr ;;
                debian-archive-keyring) sudo apt-get install -y debian-archive-keyring ;;
                ubuntu-keyring) sudo apt-get install -y ubuntu-keyring ;;
                oras) \
                  curl -sSfL https://github.com/oras-project/oras/releases/latest/download/oras_$(uname -s | tr '[:upper:]' '[:lower:]')_amd64.tar.gz \
                  | sudo tar -xz -C /usr/local/bin oras ;;
                syft) \
                  curl -fsSL https://raw.githubusercontent.com/anchore/sbom-action/main/install.sh | bash -s -- -b /usr/local/bin v1.31.0 ;;
                *) sudo apt-get install -y "$cmd" || true ;;
              esac
            fi
          }

          # 배포판별 공식 ISO/체크섬/서명 주소
          set_official_iso_vars(){
            local d="$1"
            case "$d" in
              ubuntu)
                ISO_URL="https://releases.ubuntu.com/24.04.3/ubuntu-24.04.3-live-server-amd64.iso"
                FILE_NAME="ubuntu-24.04.3-live-server-amd64.iso"
                SUM_TYPE="sha256"
                SUM_URL="https://releases.ubuntu.com/24.04.3/SHA256SUMS"
                SUM_SIG_URL="https://releases.ubuntu.com/24.04.3/SHA256SUMS.gpg"
                ;;
              debian)
                ISO_URL="https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/debian-13.1.0-amd64-netinst.iso"
                FILE_NAME="debian-13.1.0-amd64-netinst.iso"
                SUM_TYPE="sha512"
                SUM_URL="https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/SHA512SUMS"
                SUM_SIG_URL="https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/SHA512SUMS.sign"
                ;;
              rocky)
                ISO_URL="https://download.rockylinux.org/pub/rocky/9/isos/x86_64/Rocky-9-latest-x86_64-minimal.iso"
                FILE_NAME="Rocky-9-latest-x86_64-minimal.iso"
                SUM_TYPE="sha256"
                SUM_URL="https://download.rockylinux.org/pub/rocky/9/isos/x86_64/CHECKSUM"
                ;;
              alma)
                ISO_URL="https://repo.almalinux.org/almalinux/9/isos/x86_64/AlmaLinux-9-latest-x86_64-minimal.iso"
                FILE_NAME="AlmaLinux-9-latest-x86_64-minimal.iso"
                SUM_TYPE="sha256"
                SUM_URL="https://repo.almalinux.org/almalinux/9/isos/x86_64/CHECKSUM"
                ;;
              rhel) # 인증 필요 → AlmaLinux로 자동 대체
                ISO_URL="https://repo.almalinux.org/almalinux/9/isos/x86_64/AlmaLinux-9-latest-x86_64-minimal.iso"
                FILE_NAME="AlmaLinux-9-latest-x86_64-minimal.iso"
                SUM_TYPE="sha256"
                SUM_URL="https://repo.almalinux.org/almalinux/9/isos/x86_64/CHECKSUM"
                FALLBACK_NOTE="Requested 'rhel' but used AlmaLinux (auth required for RHEL)."
                ;;
              *) ISO_URL=""; FILE_NAME="";;
            esac
          }

          # 체크섬 리스트에서 해당 파일 라인만 표준 포맷으로 정규화하여 검증
          verify_sum(){
            local fpath="$1"      # full path to target file
            local stype="$2"      # sha256|sha512
            local list_path="$3"  # checksum list file
            local dir base tmp
            dir="$(dirname "$fpath")"; base="$(basename "$fpath")"
            if [[ -n "$list_path" && -f "$list_path" ]]; then
              tmp="$dir/.sumline.$$.$stype"
              awk -v f="$base" '{ fn=$2; sub(/^\*/, "", fn); if (fn==f) print $1 "  " f }' "$list_path" > "$tmp"
              if [[ ! -s "$tmp" ]]; then
                echoe "WARN: checksum entry for $base not found in $(basename "$list_path"); computing local hash only"
                rm -f "$tmp"
                if [[ "$stype" = "sha512" ]]; then ( cd "$dir" && sha512sum "$base" | tee "${base}.sha512.txt" )
                else ( cd "$dir" && sha256sum "$base" | tee "${base}.sha256.txt" ); fi
                return
              fi
              if [[ "$stype" = "sha512" ]]; then ( cd "$dir" && sha512sum -c "$(basename "$tmp")" )
              else ( cd "$dir" && sha256sum -c "$(basename "$tmp")" ); fi
              rm -f "$tmp"
            else
              echoe "WARN: checksum list not found; computing local $stype only"
              if [[ "$stype" = "sha512" ]]; then ( cd "$dir" && sha512sum "$base" | tee "${base}.sha512.txt" )
              else ( cd "$dir" && sha256sum "$base" | tee "${base}.sha256.txt" ); fi
            fi
          }

          # Ubuntu/Debian GPG 검증
          verify_gpg(){
            local stype="$1"     # sha256|sha512
            local sums="$2"      # path to SUMS file
            local sig="$3"       # path to signature
            local distro="$4"    # ubuntu|debian|...
            echoe "GPG verify: distro=$distro, $sums vs $sig"
            case "$distro" in
              ubuntu)
                if [ -f /usr/share/keyrings/ubuntu-archive-keyring.gpg ]; then
                  gpgv --keyring /usr/share/keyrings/ubuntu-archive-keyring.gpg "$sig" "$sums" \
                    && { echoe "Ubuntu GPG OK (keyring)"; return; } || echoe "WARN: ubuntu-keyring gpgv failed; trying keyserver..."
                fi
                gpg --batch --keyserver hkps://keyserver.ubuntu.com --recv-keys 0xD94AA3F0EFE21092 0x46181433FBB75451 || true
                gpg --verify "$sig" "$sums" && echoe "Ubuntu GPG OK (keyserver)" || echoe "WARN: Ubuntu GPG verify failed"
                ;;
              debian)
                if [ -f /usr/share/keyrings/debian-archive-keyring.gpg ]; then
                  gpgv --keyring /usr/share/keyrings/debian-archive-keyring.gpg "$sig" "$sums" \
                    && { echoe "Debian GPG OK (keyring)"; return; } || echoe "WARN: debian-keyring gpgv failed"
                else
                  echoe "WARN: debian-archive-keyring missing"
                fi
                ;;
              *)
                echoe "GPG verify skipped for $distro"
                ;;
            esac
          }
          EOS
          chmod +x "$ECHO_ROOT/echo_tools.sh"

      - name: Generate bulk directories/files (mandatory)
        shell: bash
        run: |
          set -Eeuo pipefail
          source "$ECHO_ROOT/echo_tools.sh"
          SPEC_FILE="$META_DIR/dir_spec.txt"
          echo "linux:100,rhel:100" > "$SPEC_FILE"
          while read -r PREFIX COUNT; do
            echoe "Generating prefix=$PREFIX count=$COUNT"
            BASE="$ECHO_ROOT/$PREFIX/bulk"
            for ((i=1;i<=COUNT;i++)); do
              D="$BASE/${PREFIX}_dir_$i"
              mkdir -p "$D/sub1" "$D/sub2"
              echo "sample file for $PREFIX #$i" > "$D/README.txt"
              printf '{"prefix":"%s","index":%d,"ts":"%s"}\n' "$PREFIX" "$i" "$(date -u +'%F %T')" > "$D/meta.json"
            done
          done < "$SPEC_FILE"
          tar -C "$ECHO_ROOT" -cf "$DIST_DIR/echo_bulk.tar" .
          echoe "Bulk generated -> $DIST_DIR/echo_bulk.tar"

      - name: Download official base ISO + GPG verify (mandatory)
        shell: bash
        run: |
          set -Eeuo pipefail
          source "$ECHO_ROOT/echo_tools.sh"
          ensure_cmd curl; ensure_cmd sha256sum; ensure_cmd sha512sum; ensure_cmd file; ensure_cmd jq
          ensure_cmd gpg; ensure_cmd gpgv; ensure_cmd dirmngr
          ensure_cmd debian-archive-keyring || true
          ensure_cmd ubuntu-keyring || true

          D="${{ inputs.distro || github.event.inputs.distro }}"
          set_official_iso_vars "$D"
          [[ -z "$ISO_URL" ]] && fail "No ISO URL resolved"

          echoe "Base ISO URL: $ISO_URL"
          echoe "Checksum List: ${SUM_URL:-none} (${SUM_TYPE:-sha256})"
          echoe "Signature URL: ${SUM_SIG_URL:-none}"
          jq -n --arg url "$ISO_URL" --arg sumurl "${SUM_URL:-}" --arg sigurl "${SUM_SIG_URL:-}" --arg sumtype "${SUM_TYPE:-sha256}" --arg note "${FALLBACK_NOTE:-}" \
            '{base_iso_url:$url, checksum_url:$sumurl, signature_url:$sigurl, checksum_type:$sumtype, note:$note}' \
            | tee "$META_DIR/base_iso.urls.json"

          OUT="$ISO_DIR/$FILE_NAME"
          curl -fL "$ISO_URL" -o "$OUT"
          file "$OUT" | tee "$META_DIR/base_iso.file.txt"

          LIST=""
          if [[ -n "$SUM_URL" ]]; then
            LIST="$ISO_DIR/$(basename "$SUM_URL")"
            curl -fsSL "$SUM_URL" -o "$LIST" || echoe "WARN: checksum list fetch failed"
          fi
          if [[ -n "$SUM_SIG_URL" && -n "$LIST" && -f "$LIST" ]]; then
            SIG="$ISO_DIR/$(basename "$SUM_SIG_URL")"
            curl -fsSL "$SUM_SIG_URL" -o "$SIG" || echoe "WARN: signature fetch failed"
            verify_gpg "${SUM_TYPE:-sha256}" "$LIST" "$SIG" "$D" || echoe "WARN: GPG verification did not fully pass"
          fi
          verify_sum "$OUT" "${SUM_TYPE:-sha256}" "${LIST:-}"

      - name: Create custom content ISO (mandatory; payload = ECHO_ROOT snapshot)
        shell: bash
        run: |
          set -Eeuo pipefail
          source "$ECHO_ROOT/echo_tools.sh"
          if ! command -v mkisofs >/dev/null 2>&1; then ensure_cmd mkisofs || true; fi
          if ! command -v mkisofs >/dev/null 2>&1 && ! command -v xorriso >/dev/null 2>&1; then ensure_cmd xorriso; fi
          SRC="$ECHO_ROOT"
          LABEL="ECHO_DATA_$(date -u +%Y%m%d)"
          ISO_OUT="$ISO_DIR/custom_payload.iso"
          if command -v mkisofs >/dev/null 2>&1; then
            mkisofs -V "$LABEL" -J -R -o "$ISO_OUT" "$SRC" 2>&1 | tee "$LOG_DIR/mkisofs_payload.log"
          else
            xorriso -as mkisofs -V "$LABEL" -J -R -o "$ISO_OUT" "$SRC" 2>&1 | tee "$LOG_DIR/xorriso_payload.log"
          fi
          sha256sum "$ISO_OUT" | tee "$META_DIR/custom_payload.sha256.txt"

      - name: Prepare Cloud-Init / Kickstart / Preseed seeds (mandatory)
        shell: bash
        run: |
          set -Eeuo pipefail
          source "$ECHO_ROOT/echo_tools.sh"
          ensure_cmd mkisofs || ensure_cmd xorriso
          # Cloud-Init
          cat > "$SEED_DIR/cloud-init/user-data" <<'UD'
          #cloud-config
          hostname: echo-host
          users:
            - name: ubuntu
              sudo: ALL=(ALL) NOPASSWD:ALL
              groups: users, admin, sudo
              lock_passwd: false
              plain_text_passwd: "echo1234"
          ssh_pwauth: true
          packages: [vim, curl]
          runcmd:
            - [ bash, -lc, "echo 'hello from cloud-init' > /root/hello.txt" ]
          UD
          echo "instance-id: iid-echo; local-hostname: echo-host" > "$SEED_DIR/cloud-init/meta-data"

          # Kickstart (RHEL family)
          cat > "$SEED_DIR/kickstart/ks.cfg" <<'KS'
          #version=RHEL9
          text
          lang en_US.UTF-8
          keyboard us
          timezone UTC
          rootpw echo1234
          network --bootproto=dhcp
          firewall --enabled
          selinux --enforcing
          services --enabled=sshd
          bootloader --location=mbr
          autopart --type=lvm
          %packages
          @^minimal-environment
          vim
          %end
          %post
          echo "hello from kickstart" > /root/ks_hello.txt
          %end
          KS

          # Preseed (Debian/Ubuntu legacy)
          cat > "$SEED_DIR/preseed/preseed.cfg" <<'PS'
          d-i debian-installer/locale string en_US
          d-i keyboard-configuration/layoutcode string us
          d-i netcfg/choose_interface select auto
          d-i time/zone string UTC
          d-i passwd/user-fullname string Echo User
          d-i passwd/username string echo
          d-i passwd/user-password password echo1234
          d-i passwd/user-password-again password echo1234
          d-i pkgsel/include string vim curl
          PS

          # Cloud-Init 전용 ISO(CIDATA)
          CIDATA="$ISO_DIR/seed-cidata.iso"
          if command -v mkisofs >/dev/null 2>&1; then
            mkisofs -V CIDATA -J -R -o "$CIDATA" "$SEED_DIR/cloud-init"
          else
            xorriso -as mkisofs -V CIDATA -J -R -o "$CIDATA" "$SEED_DIR/cloud-init"
          fi
          sha256sum "$CIDATA" | tee "$META_DIR/seed_cidata.sha256.txt"
          echoe "Seed ISO created -> $CIDATA"

      - name: Build FULL bootable custom installer ISO (UEFI+BIOS, auto params injected)
        shell: bash
        run: |
          set -Eeuo pipefail
          source "$ECHO_ROOT/echo_tools.sh"
          ensure_cmd xorriso; ensure_cmd isohybrid || true; ensure_cmd isohdpfx.bin || true

          D="${{ inputs.distro || github.event.inputs.distro }}"
          BASE_ISO="$ISO_DIR/$(
            jq -r '.base_iso_url' "$META_DIR/base_iso.urls.json" | awk -F/ '{print $NF}'
          )"
          [[ ! -f "$BASE_ISO" ]] && BASE_ISO="$ISO_DIR/$(ls -1 "$ISO_DIR" | grep -E '\.iso$' | head -n1)"
          [[ ! -f "$BASE_ISO" ]] && fail "Base ISO not found"

          WORK="$WORK_DIR/root"
          rm -rf "$WORK"; mkdir -p "$WORK"
          xorriso -osirrox on -indev "$BASE_ISO" -extract / "$WORK"
          chmod -R u+w "$WORK" || true

          case "$D" in
            ubuntu)
              mkdir -p "$WORK/nocloud"
              cp "$SEED_DIR/cloud-init/user-data" "$WORK/nocloud/user-data"
              cp "$SEED_DIR/cloud-init/meta-data" "$WORK/nocloud/meta-data"
              for GRUB_CAND in \
                "$WORK/boot/grub/grub.cfg" \
                "$WORK/EFI/BOOT/grub.cfg" \
                "$WORK/boot/grub/loopback.cfg" \
                "$WORK/isolinux/txt.cfg"
              do
                [ -f "$GRUB_CAND" ] || continue
                if grep -qE '^\s*linux(\s|efi)\s' "$GRUB_CAND"; then
                  sed -i 's,^\(\s*linux[^#]*\)$,\1 autoinstall ds=nocloud;s=/cdrom/nocloud/,' "$GRUB_CAND" || true
                elif grep -qE '^\s*append\s' "$GRUB_CAND"; then
                  sed -i 's,^\(\s*append .*\)$,\1 autoinstall ds=nocloud;s=/cdrom/nocloud/,' "$GRUB_CAND" || true
                fi
              done
              ;;
            debian)
              mkdir -p "$WORK/preseed"
              cp "$SEED_DIR/preseed/preseed.cfg" "$WORK/preseed/preseed.cfg"
              for CFG in "$WORK/isolinux/txt.cfg" "$WORK/boot/grub/grub.cfg" "$WORK/EFI/BOOT/grub.cfg"; do
                [ -f "$CFG" ] || continue
                if grep -qE '^\s*linux(\s|efi)\s' "$CFG"; then
                  sed -i 's,^\(\s*linux[^#]*\)$,\1 auto=true priority=critical file=/cdrom/preseed/preseed.cfg,' "$CFG" || true
                elif grep -qE '^\s*append\s' "$CFG"; then
                  sed -i 's,^\(\s*append .*\)$,\1 auto=true priority=critical file=/cdrom/preseed/preseed.cfg,' "$CFG" || true
                fi
              done
              ;;
            rocky|alma|rhel)
              cp "$SEED_DIR/kickstart/ks.cfg" "$WORK/ks.cfg"
              for CFG in "$WORK/isolinux/isolinux.cfg" "$WORK/EFI/BOOT/grub.cfg" "$WORK/boot/grub/grub.cfg"; do
                [ -f "$CFG" ] || continue
                if grep -qE '^\s*linuxefi\s' "$CFG"; then
                  sed -i 's,^\(\s*linuxefi\s\+\S\+\s\+.*\)$,\1 inst.ks=cdrom:/ks.cfg,' "$CFG" || true
                elif grep -qE '^\s*linux\s' "$CFG"; then
                  sed -i 's,^\(\s*linux\s\+\S\+\s\+.*\)$,\1 inst.ks=cdrom:/ks.cfg,' "$CFG" || true
                elif grep -qE '^\s*append\s' "$CFG"; then
                  sed -i 's,^\(\s*append .*\)$,\1 inst.ks=cdrom:/ks.cfg,' "$CFG" || true
                fi
              done
              ;;
          esac

          HAS_ISOLINUX_BIN=false
          HAS_GRUB_BIOS_IMG=false
          HAS_GRUB_EFI_IMG=false
          ISOHYBRID_MBR="/usr/lib/ISOLINUX/isohdpfx.bin"

          [ -f "$WORK/isolinux/isolinux.bin" ] && HAS_ISOLINUX_BIN=true
          [ -f "$WORK/boot/grub/i386-pc/eltorito.img" ] && HAS_GRUB_BIOS_IMG=true
          if [ -f "$WORK/boot/grub/efi.img" ]; then
            EFI_IMG_PATH="boot/grub/efi.img"; HAS_GRUB_EFI_IMG=true
          elif [ -f "$WORK/efi.img" ]; then
            EFI_IMG_PATH="efi.img"; HAS_GRUB_EFI_IMG=true
          else
            EFI_IMG_PATH=""
          fi

          OUT="$ISO_DIR/custom_installer_${D}.iso"
          LABEL="ECHO_INST_${D}_$(date -u +%Y%m%d)"

          if $HAS_ISOLINUX_BIN; then
            if $HAS_GRUB_EFI_IMG; then
              xorriso -as mkisofs -r -V "$LABEL" -o "$OUT" -J -l \
                -isohybrid-mbr "$ISOHYBRID_MBR" \
                -c isolinux/boot.cat \
                -b isolinux/isolinux.bin \
                  -no-emul-boot -boot-load-size 4 -boot-info-table \
                -eltorito-alt-boot \
                -e "$EFI_IMG_PATH" -no-emul-boot -isohybrid-gpt-basdat \
                "$WORK"
            else
              xorriso -as mkisofs -r -V "$LABEL" -o "$OUT" -J -l \
                -isohybrid-mbr "$ISOHYBRID_MBR" \
                -c isolinux/boot.cat \
                -b isolinux/isolinux.bin \
                  -no-emul-boot -boot-load-size 4 -boot-info-table \
                "$WORK"
            fi
          else
            if $HAS_GRUB_BIOS_IMG && $HAS_GRUB_EFI_IMG; then
              xorriso -as mkisofs -r -V "$LABEL" -o "$OUT" -J -l \
                -isohybrid-mbr "$ISOHYBRID_MBR" \
                -c boot.cat \
                -b boot/grub/i386-pc/eltorito.img \
                  -no-emul-boot -boot-load-size 4 -boot-info-table \
                -eltorito-alt-boot \
                -e "$EFI_IMG_PATH" -no-emul-boot -isohybrid-gpt-basdat \
                "$WORK"
            elif $HAS_GRUB_EFI_IMG; then
              xorriso -as mkisofs -r -V "$LABEL" -o "$OUT" -J -l \
                -e "$EFI_IMG_PATH" -no-emul-boot -isohybrid-gpt-basdat \
                "$WORK"
            else
              fail "No boot assets found (neither isolinux nor GRUB eltorito/efi images)"
            fi
          fi

          sha256sum "$OUT" | tee "$META_DIR/custom_installer.sha256.txt"
          echoe "Bootable custom installer ISO -> $OUT"

      - name: Post-ISO:create extra bulk and MOVE data (mandatory)
        shell: bash
        run: |
          set -Eeuo pipefail
          source "$ECHO_ROOT/echo_tools.sh"
          EXTRA="$ECHO_ROOT/after_iso_payload"
          mkdir -p "$EXTRA/bulk_extra"
          for i in $(seq 1 50); do
            mkdir -p "$EXTRA/bulk_extra/extra_${i}/subA" "$EXTRA/bulk_extra/extra_${i}/subB"
            echo "extra payload $i" > "$EXTRA/bulk_extra/extra_${i}/README.txt"
          done
          if [ -d "$ECHO_ROOT/linux/bulk" ]; then
            mkdir -p "$EXTRA/bulk_from_linux"
            find "$ECHO_ROOT/linux/bulk" -mindepth 1 -maxdepth 1 -type d -print0 | xargs -0 -I{} mv "{}" "$EXTRA/bulk_from_linux"/
          fi
          if [ -d "$ECHO_ROOT/rhel/bulk" ]; then
            mkdir -p "$EXTRA/bulk_from_rhel"
            find "$ECHO_ROOT/rhel/bulk" -mindepth 1 -maxdepth 1 -type d -print0 | xargs -0 -I{} mv "{}" "$EXTRA/bulk_from_rhel"/
          fi
          tar -C "$EXTRA" -cf "$DIST_DIR/after_iso_payload.tar" .
          echoe "Moved/extended payload -> $DIST_DIR/after_iso_payload.tar"

      - name: Create QCOW2 base & snapshot (mandatory; fixed backing + absolute meta/log paths)
        shell: bash
        run: |
          set -Eeuo pipefail
          source "$ECHO_ROOT/echo_tools.sh"
          ensure_cmd qemu-img
          SIZE_GB="${{ inputs.qcow_size_gb || github.event.inputs.qcow_size_gb }}"
          DISTRO="${{ inputs.distro || github.event.inputs.distro }}"
          META_ABS="$GITHUB_WORKSPACE/${META_DIR}"
          LOG_ABS="$GITHUB_WORKSPACE/${LOG_DIR}"
          IMG_ABS="$GITHUB_WORKSPACE/${IMG_DIR}"
          mkdir -p "$IMG_ABS" "$META_ABS" "$LOG_ABS"
          cd "$IMG_ABS"
          BASE="base_${DISTRO}.qcow2"
          SNAP="snap_${DISTRO}.qcow2"
          echoe "Creating base QCOW2: $BASE (${SIZE_GB}G)"
          qemu-img create -f qcow2 -o cluster_size=65536,compression_type=zlib "$BASE" "${SIZE_GB}G"
          qemu-img info --output=json "$BASE" | tee "$META_ABS/qcow2_base.info.json" >/dev/null
          qemu-img check "$BASE" | tee "$LOG_ABS/qcow2_base.check.log" >/dev/null || echoe "WARN: qemu-img check returned non-zero"
          echoe "Creating snapshot with proper relative backing"
          qemu-img create -f qcow2 -b "$BASE" -F qcow2 "$SNAP"
          qemu-img info --output=json "$SNAP" | tee "$META_ABS/qcow2_snap.info.json" >/dev/null
          qemu-img check "$SNAP" | tee "$LOG_ABS/qcow2_snap.check.log" >/dev/null || echoe "WARN: qemu-img check returned non-zero"

      - name: SBOM (SPDX-JSON) generate (mandatory)
        shell: bash
        run: |
          set -Eeuo pipefail
          source "$ECHO_ROOT/echo_tools.sh"
          ensure_cmd syft
          mkdir -p "$DIST_DIR/sbom"
          syft version
          syft dir:"$DIST_DIR" -o spdx-json > "$DIST_DIR/sbom/dist.spdx.json"
          echoe "SBOM generated -> $DIST_DIR/sbom/dist.spdx.json"

      - name: Hash catalog & index (mandatory)
        shell: bash
        run: |
          set -Eeuo pipefail
          source "$ECHO_ROOT/echo_tools.sh"
          ensure_cmd jq
          HASH_JSON="$META_DIR/hash_index.json"
          : > "$HASH_JSON"
          echo "[" >> "$HASH_JSON"
          first=1
          while IFS= read -r -d '' f; do
            sha256=$(sha256sum "$f" | awk '{print $1}')
            sha512=$(sha512sum "$f" | awk '{print $1}')
            size=$(stat -c%s "$f")
            rel="${f#dist/}"
            entry=$(jq -n --arg path "$rel" --arg sha256 "$sha256" --arg sha512 "$sha512" --argjson size "$size" \
                      '{path:$path,sha256:$sha256,sha512:$sha512,size:$size}')
            if [ $first -eq 1 ]; then
              echo "  $entry" >> "$HASH_JSON"; first=0
            else
              echo " ,$entry" >> "$HASH_JSON"
            fi
          done < <(find dist -type f -print0)
          echo "]" >> "$HASH_JSON"
          echoe "Hash index -> $HASH_JSON"

      - name: GHCR upload via ORAS (mandatory)
        env:
          ORAS_REGISTRY: ghcr.io
          ORAS_REPO: ${{ github.repository }}
          ORAS_TAG: ${{ github.run_id }}
          GH_USER: ${{ github.actor }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -Eeuo pipefail
          source "$ECHO_ROOT/echo_tools.sh"
          ensure_cmd oras
          echo "$GH_TOKEN" | oras login ghcr.io -u "$GH_USER" --password-stdin
          REF="${{ env.GHCR_BASE }}:${{ env.ORAS_TAG }}"
          oras push "$REF" \
            --artifact-type application/vnd.echo.bundle \
            "$ISO_DIR/$(ls -1 $ISO_DIR | head -n1)":application/octet-stream \
            "$ISO_DIR/custom_payload.iso":application/octet-stream \
            "$ISO_DIR/custom_installer_${{ inputs.distro || github.event.inputs.distro }}.iso":application/octet-stream \
            "$ISO_DIR/seed-cidata.iso":application/octet-stream \
            "$IMG_DIR/base_${{ inputs.distro || github.event.inputs.distro }}.qcow2":application/octet-stream \
            "$IMG_DIR/snap_${{ inputs.distro || github.event.inputs.distro }}.qcow2":application/octet-stream \
            "$DIST_DIR/echo_bulk.tar":application/x-tar \
            "$DIST_DIR/after_iso_payload.tar":application/x-tar \
            "$DIST_DIR/sbom/dist.spdx.json":application/spdx+json \
            "$META_DIR/hash_index.json":application/json \
            "$META_DIR/base_iso.urls.json":application/json \
            "$META_DIR/custom_installer.sha256.txt":text/plain
          echoe "Pushed to GHCR: $REF"

      - name: Upload artifacts (mandatory)
        uses: actions/upload-artifact@v4
        with:
          name: linux-rhel-image-suite-${{ github.run_id }}
          path: |
            dist/**
          if-no-files-found: error
          retention-days: 7

      - name: Create GitHub Release (mandatory)
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ inputs.release_tag && inputs.release_tag != '' && inputs.release_tag || format('auto-{0}', github.run_id) }}
          name: "Linux/RHEL Image Suite • ${{ inputs.distro || github.event.inputs.distro }}"
          body: |
            ALL-IN-ONE image suite with GPG, FULL bootable installer ISO, Cloud-Init/Kickstart/Preseed, SBOM, GHCR, and hash index.
            - Distro: `${{ inputs.distro || github.event.inputs.distro }}`
            - Base ISO URL: (see dist/meta/base_iso.urls.json)
            - Custom payload ISO: `dist/isos/custom_payload.iso`
            - FULL installer ISO: `dist/isos/custom_installer_${{ inputs.distro || github.event.inputs.distro }}.iso`
            - Seed ISO (CIDATA): `dist/isos/seed-cidata.iso`
            - QCOW2: `dist/images/base_${{ inputs.distro || github.event.inputs.distro }}.qcow2` + `snap_${{ inputs.distro || github.event.inputs.distro }}.qcow2`
            - SBOM: `dist/sbom/dist.spdx.json`
            - Hash index: `dist/meta/hash_index.json`
            - GHCR ref: `${{ env.GHCR_BASE }}:${{ github.run_id }}`
          files: |
            dist/isos/*.iso
            dist/images/*.qcow2
            dist/meta/**
            dist/logs/**
            dist/sbom/**
            dist/echo_bulk.tar
            dist/after_iso_payload.tar
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
