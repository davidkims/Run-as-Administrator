name: "🐧 Linux/RHEL Image Suite (ALL-IN-ONE + GPG + Bootable Installer ISO + Cloud-Init/Kickstart/Preseed + QCOW2 + SBOM + GHCR + Hash Index)"

on:
  workflow_dispatch:
    inputs:
      distro:
        description: "배포판 (ubuntu|debian|rocky|alma|rhel)"
        type: choice
        required: true
        default: "ubuntu"
        options: [ "ubuntu", "debian", "rocky", "alma", "rhel" ]
      qcow_size_gb:
        description: "QCOW2 사이즈(GB)"
        required: true
        default: "8"
      release_tag:
        description: "Release 태그(비우면 auto-{run_id})"
        required: false
        default: ""
  workflow_call:
    inputs:
      distro: { type: string, required: true }
      qcow_size_gb: { type: string, default: "8" }
      release_tag: { type: string, default: "" }

permissions:
  contents: write
  packages: write

concurrency:
  group: linux-rhel-image-suite-${{ github.ref }}
  cancel-in-progress: false

jobs:
  image-suite:
    name: "ALL-IN-ONE build: Dirs + ISO DL/Create + GPG verify + Bootable Installer ISO + QCOW2 + SBOM + GHCR + Release (+ Test Server)"
    runs-on: ubuntu-latest
    env:
      ECHO_ROOT: .github/echo_linux
      DIST_DIR: dist
      ISO_DIR: dist/isos
      IMG_DIR: dist/images
      LOG_DIR: dist/logs
      META_DIR: dist/meta
      SEED_DIR: dist/seed
      WORK_DIR: dist/work
      # GHCR_BASE: 소문자 강제는 푸시 단계에서 처리(여기서는 원문 유지)
      GHCR_BASE: ghcr.io/${{ github.repository }}/image-suite

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Init dirs
        run: |
          set -Eeuo pipefail
          mkdir -p "$ECHO_ROOT"/{linux,rhel}/bulk \
                   "$DIST_DIR" "$ISO_DIR" "$IMG_DIR" "$LOG_DIR" "$META_DIR" \
                   "$SEED_DIR"/{cloud-init,preseed,kickstart} "$WORK_DIR"
          printf '[%s] INIT: dirs ready\n' "$(date -u +'%F %T')"

      - name: Echo tools (functions)
        id: echo-tools
        shell: bash
        run: |
          set -Eeuo pipefail
          cat > "$ECHO_ROOT/echo_tools.sh" <<'EOS'
          set -Eeuo pipefail
          TS(){ date -u +'%Y-%m-%dT%H:%M:%SZ'; }
          echoe(){ printf '[%s] %s\n' "$(TS)" "$*"; }
          notify(){ echo "::warning ::$*"; echoe "$*" | tee -a "${GITHUB_STEP_SUMMARY:-/dev/null}" >/dev/null; }
          softfail(){ echoe "::warning ::$*"; echoe "Continuing despite error"; }
          tryrun(){ bash -lc "$*" || { softfail "Step failed: $*"; return 0; }; }

          fail(){ echoe "::error::$*"; exit 1; }

          ensure_cmd(){
            local cmd="$1"
            if ! command -v "$cmd" >/dev/null 2>&1; then
              echoe "installing: $cmd"
              sudo apt-get update -y
              case "$cmd" in
                mkisofs) sudo apt-get install -y genisoimage ;;
                xorriso) sudo apt-get install -y xorriso ;;
                isohybrid|isohdpfx.bin) sudo apt-get install -y syslinux-utils isolinux || true ;;
                qemu-img) sudo apt-get install -y qemu-utils ;;
                curl|jq) sudo apt-get install -y curl jq ;;
                sha256sum|sha512sum) sudo apt-get install -y coreutils ;;
                file) sudo apt-get install -y file ;;
                gpg|gpgv|dirmngr) sudo apt-get install -y gnupg dirmngr ;;
                debian-archive-keyring) sudo apt-get install -y debian-archive-keyring ;;
                ubuntu-keyring) sudo apt-get install -y ubuntu-keyring ;;
                oras)
                  ensure_cmd curl; ensure_cmd jq
                  arch="$(uname -m)"
                  case "$arch" in
                    x86_64|amd64) goarch="amd64" ;;
                    aarch64|arm64) goarch="arm64" ;;
                    s390x) goarch="s390x" ;;
                    ppc64le) goarch="ppc64le" ;;
                    *) goarch="amd64" ;;
                  esac
                  tmp="$(mktemp -d)"; trap 'rm -rf "$tmp"' EXIT
                  ver="$(curl -fsSL --retry 5 --retry-connrefused https://api.github.com/repos/oras-project/oras/releases/latest | jq -r '.tag_name' | sed 's/^v//')"
                  if [ -z "$ver" ] || [ "$ver" = "null" ]; then ver="1.2.2"; notify "WARN: fallback ORAS $ver"; fi
                  url="https://github.com/oras-project/oras/releases/download/v${ver}/oras_${ver}_linux_${goarch}.tar.gz"
                  echoe "Downloading oras ${ver} (${goarch}) from: $url"
                  if ! curl -fsSL --retry 5 --retry-connrefused -o "$tmp/oras.tgz" "$url"; then
                    ver="1.2.2"
                    url="https://github.com/oras-project/oras/releases/download/v${ver}/oras_${ver}_linux_${goarch}.tar.gz"
                    curl -fsSL --retry 5 --retry-connrefused -o "$tmp/oras.tgz" "$url" || { softfail "oras download failed"; return 0; }
                  fi
                  sudo tar -xzf "$tmp/oras.tgz" -C /usr/local/bin oras || softfail "oras extract failed"
                  /usr/local/bin/oras version || softfail "oras install verify failed"
                  ;;
                syft)
                  ensure_cmd curl; ensure_cmd jq
                  arch="$(uname -m)"
                  case "$arch" in
                    x86_64|amd64) goarch="amd64" ;;
                    aarch64|arm64) goarch="arm64" ;;
                    s390x) goarch="s390x" ;;
                    ppc64le) goarch="ppc64le" ;;
                    *) goarch="amd64" ;;
                  esac
                  tmp="$(mktemp -d)"; trap 'rm -rf "$tmp"' EXIT
                  ver="$(curl -fsSL --retry 5 --retry-connrefused https://api.github.com/repos/anchore/syft/releases/latest | jq -r '.tag_name' | sed 's/^v//')"
                  if [ -z "$ver" ] || [ "$ver" = "null" ]; then ver="1.31.0"; notify "WARN: fallback syft $ver"; fi
                  url="https://github.com/anchore/syft/releases/download/v${ver}/syft_${ver}_linux_${goarch}.tar.gz"
                  echoe "Downloading syft ${ver} (${goarch}) from: $url"
                  if ! curl -fsSL --retry 5 --retry-connrefused -o "$tmp/syft.tgz" "$url"; then
                    ver="1.31.0"
                    url="https://github.com/anchore/syft/releases/download/v${ver}/syft_${ver}_linux_${goarch}.tar.gz"
                    curl -fsSL --retry 5 --retry-connrefused -o "$tmp/syft.tgz" "$url" || { softfail "syft download failed"; return 0; }
                  fi
                  sudo tar -xzf "$tmp/syft.tgz" -C /usr/local/bin syft || softfail "syft extract failed"
                  /usr/local/bin/syft version || softfail "syft install verify failed"
                  ;;
                *) sudo apt-get install -y "$cmd" || true ;;
              esac
            fi
          }

          # 공식 ISO/체크섬/서명 주소
          set_official_iso_vars(){
            local d="$1"
            case "$d" in
              ubuntu)
                ISO_URL="https://releases.ubuntu.com/24.04.3/ubuntu-24.04.3-live-server-amd64.iso"
                FILE_NAME="ubuntu-24.04.3-live-server-amd64.iso"
                SUM_TYPE="sha256"
                SUM_URL="https://releases.ubuntu.com/24.04.3/SHA256SUMS"
                SUM_SIG_URL="https://releases.ubuntu.com/24.04.3/SHA256SUMS.gpg"
                ;;
              debian)
                ISO_URL="https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/debian-13.1.0-amd64-netinst.iso"
                FILE_NAME="debian-13.1.0-amd64-netinst.iso"
                SUM_TYPE="sha512"
                SUM_URL="https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/SHA512SUMS"
                SUM_SIG_URL="https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/SHA512SUMS.sign"
                ;;
              rocky)
                ISO_URL="https://download.rockylinux.org/pub/rocky/9/isos/x86_64/Rocky-9-latest-x86_64-minimal.iso"
                FILE_NAME="Rocky-9-latest-x86_64-minimal.iso"
                SUM_TYPE="sha256"
                SUM_URL="https://download.rockylinux.org/pub/rocky/9/isos/x86_64/CHECKSUM"
                ;;
              alma)
                ISO_URL="https://repo.almalinux.org/almalinux/9/isos/x86_64/AlmaLinux-9-latest-x86_64-minimal.iso"
                FILE_NAME="AlmaLinux-9-latest-x86_64-minimal.iso"
                SUM_TYPE="sha256"
                SUM_URL="https://repo.almalinux.org/almalinux/9/isos/x86_64/CHECKSUM"
                ;;
              rhel) # 인증 필요 → AlmaLinux 대체
                ISO_URL="https://repo.almalinux.org/almalinux/9/isos/x86_64/AlmaLinux-9-latest-x86_64-minimal.iso"
                FILE_NAME="AlmaLinux-9-latest-x86_64-minimal.iso"
                SUM_TYPE="sha256"
                SUM_URL="https://repo.almalinux.org/almalinux/9/isos/x86_64/CHECKSUM"
                FALLBACK_NOTE="Requested 'rhel' but used AlmaLinux (auth required for RHEL)."
                ;;
              *) ISO_URL=""; FILE_NAME="";;
            esac
          }

          # 체크섬 검증
          verify_sum(){
            local fpath="$1"; local stype="$2"; local list_path="$3"
            local dir base tmp; dir="$(dirname "$fpath")"; base="$(basename "$fpath")"
            if [[ -n "$list_path" && -f "$list_path" ]]; then
              tmp="$dir/.sum.$$.$stype"
              awk -v f="$base" '{ fn=$2; sub(/^\*/, "", fn); if (fn==f) print $1 "  " f }' "$list_path" > "$tmp"
              if [[ ! -s "$tmp" ]]; then
                notify "checksum entry for $base not found; computing local hash only"
                rm -f "$tmp"
                if [[ "$stype" = "sha512" ]]; then ( cd "$dir" && sha512sum "$base" | tee "${base}.sha512.txt" )
                else ( cd "$dir" && sha256sum "$base" | tee "${base}.sha256.txt" ); fi
                return
              fi
              if [[ "$stype" = "sha512" ]]; then ( cd "$dir" && sha512sum -c "$(basename "$tmp")" ) || softfail "sha512 verify failed"
              else ( cd "$dir" && sha256sum -c "$(basename "$tmp")" ) || softfail "sha256 verify failed"
              fi
              rm -f "$tmp"
            else
              notify "checksum list not found; computing local $stype only"
              if [[ "$stype" = "sha512" ]]; then ( cd "$dir" && sha512sum "$base" | tee "${base}.sha512.txt" )
              else ( cd "$dir" && sha256sum "$base" | tee "${base}.sha256.txt" ); fi
            fi
          }

          # Ubuntu/Debian GPG 검증
          verify_gpg(){
            local stype="$1"; local sums="$2"; local sig="$3"; local distro="$4"
            echoe "GPG verify: distro=$distro, $sums vs $sig"
            case "$distro" in
              ubuntu)
                if [ -f /usr/share/keyrings/ubuntu-archive-keyring.gpg ]; then
                  gpgv --keyring /usr/share/keyrings/ubuntu-archive-keyring.gpg "$sig" "$sums" \
                    && { echoe "Ubuntu GPG OK (keyring)"; return; } || notify "ubuntu-keyring gpgv failed; trying keyserver..."
                fi
                gpg --batch --keyserver hkps://keyserver.ubuntu.com --recv-keys 0xD94AA3F0EFE21092 0x46181433FBB75451 || true
                gpg --verify "$sig" "$sums" && echoe "Ubuntu GPG OK (keyserver)" || softfail "Ubuntu GPG verify failed"
                ;;
              debian)
                if [ -f /usr/share/keyrings/debian-archive-keyring.gpg ]; then
                  gpgv --keyring /usr/share/keyrings/debian-archive-keyring.gpg "$sig" "$sums" \
                    && { echoe "Debian GPG OK (keyring)"; return; } || softfail "debian-keyring gpgv failed"
                else
                  notify "debian-archive-keyring missing"
                fi
                ;;
              *) notify "GPG verify skipped for $distro" ;;
            esac
          }
          EOS
          chmod +x "$ECHO_ROOT/echo_tools.sh"

      - name: Generate bulk directories/files (mandatory)
        continue-on-error: true
        shell: bash
        run: |
          set -Eeuo pipefail
          source "$ECHO_ROOT/echo_tools.sh"
          SPEC_FILE="$META_DIR/dir_spec.txt"
          echo "linux:100,rhel:100" > "$SPEC_FILE"
          while read -r PREFIX COUNT; do
            echoe "Generating prefix=$PREFIX count=$COUNT"
            BASE="$ECHO_ROOT/$PREFIX/bulk"
            for ((i=1;i<=COUNT;i++)); do
              D="$BASE/${PREFIX}_dir_$i"
              tryrun "mkdir -p '$D/sub1' '$D/sub2'"
              echo "sample file for $PREFIX #$i" > "$D/README.txt" || softfail "write README failed: $D"
              printf '{"prefix":"%s","index":%d,"ts":"%s"}\n' "$PREFIX" "$i" "$(date -u +'%F %T')" > "$D/meta.json" || softfail "write meta failed: $D"
            done
          done < "$SPEC_FILE"
          tryrun "tar -C '$ECHO_ROOT' -cf '$DIST_DIR/echo_bulk.tar' ."
          echoe "Bulk generated -> $DIST_DIR/echo_bulk.tar"

      - name: Download official base ISO + GPG verify (mandatory)
        continue-on-error: true
        shell: bash
        run: |
          set -Eeuo pipefail
          source "$ECHO_ROOT/echo_tools.sh"
          ensure_cmd curl; ensure_cmd sha256sum; ensure_cmd sha512sum; ensure_cmd file; ensure_cmd jq
          ensure_cmd gpg; ensure_cmd gpgv; ensure_cmd dirmngr
          ensure_cmd debian-archive-keyring || true
          ensure_cmd ubuntu-keyring || true
          D="${{ inputs.distro || github.event.inputs.distro }}"
          set_official_iso_vars "$D"
          [[ -z "$ISO_URL" ]] && { softfail "No ISO URL resolved"; exit 0; }
          echoe "Base ISO URL: $ISO_URL"
          echoe "Checksum List: ${SUM_URL:-none} (${SUM_TYPE:-sha256})"
          echoe "Signature URL: ${SUM_SIG_URL:-none}"
          jq -n --arg url "$ISO_URL" --arg sumurl "${SUM_URL:-}" --arg sigurl "${SUM_SIG_URL:-}" --arg sumtype "${SUM_TYPE:-sha256}" --arg note "${FALLBACK_NOTE:-}" \
            '{base_iso_url:$url, checksum_url:$sumurl, signature_url:$sigurl, checksum_type:$sumtype, note:$note}' \
            | tee "$META_DIR/base_iso.urls.json" >/dev/null
          OUT="$ISO_DIR/$FILE_NAME"
          tryrun "curl -fL '$ISO_URL' -o '$OUT'"
          if [ -f "$OUT" ]; then
            file "$OUT" | tee "$META_DIR/base_iso.file.txt" >/dev/null
            LIST=""
            if [[ -n "$SUM_URL" ]]; then
              LIST="$ISO_DIR/$(basename "$SUM_URL")"
              tryrun "curl -fsSL '$SUM_URL' -o '$LIST'"
            fi
            if [[ -n "$SUM_SIG_URL" && -n "$LIST" && -f "$LIST" ]]; then
              SIG="$ISO_DIR/$(basename "$SUM_SIG_URL")"
              tryrun "curl -fsSL '$SUM_SIG_URL' -o '$SIG'"
              [ -f "$SIG" ] && verify_gpg "${SUM_TYPE:-sha256}" "$LIST" "$SIG" "$D"
            fi
            verify_sum "$OUT" "${SUM_TYPE:-sha256}" "${LIST:-}"
          else
            softfail "Base ISO download missing"
          fi

      - name: Create custom content ISO (payload = ECHO_ROOT snapshot)
        continue-on-error: true
        shell: bash
        run: |
          set -Eeuo pipefail
          source "$ECHO_ROOT/echo_tools.sh"
          if ! command -v mkisofs >/dev/null 2>&1; then ensure_cmd mkisofs || true; fi
          if ! command -v mkisofs >/dev/null 2>&1 && ! command -v xorriso >/dev/null 2>&1; then ensure_cmd xorriso; fi
          SRC="$ECHO_ROOT"
          LABEL="ECHO_DATA_$(date -u +%Y%m%d)"
          ISO_OUT="$ISO_DIR/custom_payload.iso"
          if command -v mkisofs >/dev/null 2>&1; then
            tryrun "mkisofs -V '$LABEL' -J -R -o '$ISO_OUT' '$SRC' 2>&1 | tee '$LOG_DIR/mkisofs_payload.log'"
          else
            tryrun "xorriso -as mkisofs -V '$LABEL' -J -R -o '$ISO_OUT' '$SRC' 2>&1 | tee '$LOG_DIR/xorriso_payload.log'"
          fi
          [ -f "$ISO_OUT" ] && sha256sum "$ISO_OUT" | tee "$META_DIR/custom_payload.sha256.txt" >/dev/null || softfail "custom payload ISO missing"

      - name: Prepare Cloud-Init / Kickstart / Preseed seeds
        continue-on-error: true
        shell: bash
        run: |
          set -Eeuo pipefail
          source "$ECHO_ROOT/echo_tools.sh"
          ensure_cmd mkisofs || ensure_cmd xorriso
          # Cloud-Init
          cat > "$SEED_DIR/cloud-init/user-data" <<'UD'
          #cloud-config
          hostname: echo-host
          users:
            - name: ubuntu
              sudo: ALL=(ALL) NOPASSWD:ALL
              groups: users, admin, sudo
              lock_passwd: false
              plain_text_passwd: "echo1234"
          ssh_pwauth: true
          packages: [vim, curl]
          runcmd:
            - [ bash, -lc, "echo 'hello from cloud-init' > /root/hello.txt" ]
          UD
          echo "instance-id: iid-echo; local-hostname: echo-host" > "$SEED_DIR/cloud-init/meta-data"
          # Kickstart (RHEL family)
          cat > "$SEED_DIR/kickstart/ks.cfg" <<'KS'
          #version=RHEL9
          text
          lang en_US.UTF-8
          keyboard us
          timezone UTC
          rootpw echo1234
          network --bootproto=dhcp
          firewall --enabled
          selinux --enforcing
          services --enabled=sshd
          bootloader --location=mbr
          autopart --type=lvm
          %packages
          @^minimal-environment
          vim
          %end
          %post
          echo "hello from kickstart" > /root/ks_hello.txt
          %end
          KS
          # Preseed (Debian/Ubuntu legacy)
          cat > "$SEED_DIR/preseed/preseed.cfg" <<'PS'
          d-i debian-installer/locale string en_US
          d-i keyboard-configuration/layoutcode string us
          d-i netcfg/choose_interface select auto
          d-i time/zone string UTC
          d-i passwd/user-fullname string Echo User
          d-i passwd/username string echo
          d-i passwd/user-password password echo1234
          d-i passwd/user-password-again password echo1234
          d-i pkgsel/include string vim curl
          PS
          # Cloud-Init 전용 ISO(CIDATA)
          CIDATA="$ISO_DIR/seed-cidata.iso"
          if command -v mkisofs >/dev/null 2>&1; then
            tryrun "mkisofs -V CIDATA -J -R -o '$CIDATA' '$SEED_DIR/cloud-init'"
          else
            tryrun "xorriso -as mkisofs -V CIDATA -J -R -o '$CIDATA' '$SEED_DIR/cloud-init'"
          fi
          [ -f "$CIDATA" ] && sha256sum "$CIDATA" | tee "$META_DIR/seed_cidata.sha256.txt" >/dev/null || softfail "seed-cidata.iso missing"

      - name: Build FULL bootable custom installer ISO (UEFI+BIOS, auto params)
        continue-on-error: true
        shell: bash
        run: |
          set -Eeuo pipefail
          source "$ECHO_ROOT/echo_tools.sh"
          ensure_cmd xorriso; ensure_cmd isohybrid || true; ensure_cmd isohdpfx.bin || true
          D="${{ inputs.distro || github.event.inputs.distro }}"
          BASE_ISO="$ISO_DIR/$(
            jq -r '.base_iso_url' "$META_DIR/base_iso.urls.json" 2>/dev/null | awk -F/ '{print $NF}'
          )"
          [[ -z "$BASE_ISO" || ! -f "$BASE_ISO" ]] && BASE_ISO="$ISO_DIR/$(ls -1 "$ISO_DIR" 2>/dev/null | grep -E '\.iso$' | head -n1 || true)"
          [[ -z "$BASE_ISO" || ! -f "$BASE_ISO" ]] && { softfail "Base ISO not found"; exit 0; }
          WORK="$WORK_DIR/root"
          rm -rf "$WORK"; mkdir -p "$WORK"
          # 1) ISO 전체 추출
          tryrun "xorriso -osirrox on -indev '$BASE_ISO' -extract / '$WORK'"
          chmod -R u+w "$WORK" || true
          # 2) 자동 설치 파라미터/파일 주입
          case "$D" in
            ubuntu)
              mkdir -p "$WORK/nocloud"
              cp "$SEED_DIR/cloud-init/user-data" "$WORK/nocloud/user-data" || true
              cp "$SEED_DIR/cloud-init/meta-data" "$WORK/nocloud/meta-data" || true
              for CFG in "$WORK/boot/grub/grub.cfg" "$WORK/EFI/BOOT/grub.cfg" "$WORK/boot/grub/loopback.cfg" "$WORK/isolinux/txt.cfg"; do
                [ -f "$CFG" ] || continue
                if grep -qE '^\s*linux(efi)?\s' "$CFG"; then
                  sed -i 's,^\(\s*linux[^#]*\)$,\1 autoinstall ds=nocloud;s=/cdrom/nocloud/,' "$CFG" || true
                elif grep -qE '^\s*append\s' "$CFG"; then
                  sed -i 's,^\(\s*append .*\)$,\1 autoinstall ds=nocloud;s=/cdrom/nocloud/,' "$CFG" || true
                fi
              done
              ;;
            debian)
              mkdir -p "$WORK/preseed"
              cp "$SEED_DIR/preseed/preseed.cfg" "$WORK/preseed/preseed.cfg" || true
              for CFG in "$WORK/isolinux/txt.cfg" "$WORK/boot/grub/grub.cfg" "$WORK/EFI/BOOT/grub.cfg"; do
                [ -f "$CFG" ] || continue
                if grep -qE '^\s*linux(efi)?\s' "$CFG"; then
                  sed -i 's,^\(\s*linux[^#]*\)$,\1 auto=true priority=critical file=/cdrom/preseed/preseed.cfg,' "$CFG" || true
                elif grep -qE '^\s*append\s' "$CFG"; then
                  sed -i 's,^\(\s*append .*\)$,\1 auto=true priority=critical file=/cdrom/preseed/preseed.cfg,' "$CFG" || true
                fi
              done
              ;;
            rocky|alma|rhel)
              cp "$SEED_DIR/kickstart/ks.cfg" "$WORK/ks.cfg" || true
              for CFG in "$WORK/isolinux/isolinux.cfg" "$WORK/EFI/BOOT/grub.cfg" "$WORK/boot/grub/grub.cfg"; do
                [ -f "$CFG" ] || continue
                if grep -qE '^\s*linuxefi\s' "$CFG"; then
                  sed -i 's,^\(\s*linuxefi\s\+\S\+\s\+.*\)$,\1 inst.ks=cdrom:/ks.cfg,' "$CFG" || true
                elif grep -qE '^\s*linux\s' "$CFG"; then
                  sed -i 's,^\(\s*linux\s\+\S\+\s\+.*\)$,\1 inst.ks=cdrom:/ks.cfg,' "$CFG" || true
                elif grep -qE '^\s*append\s' "$CFG"; then
                  sed -i 's,^\(\s*append .*\)$,\1 inst.ks=cdrom:/ks.cfg,' "$CFG" || true
                fi
              done
              ;;
          esac
          # 3) 부트 자산 탐지 + 생성
          BIOS_IMG=""; EFI_IMG=""; CATALOG=""
          [ -f "$WORK/boot/grub/i386-pc/eltorito.img" ] && { BIOS_IMG="boot/grub/i386-pc/eltorito.img"; CATALOG="boot.catalog"; }
          [ -z "$BIOS_IMG" ] && [ -f "$WORK/isolinux/isolinux.bin" ] && { BIOS_IMG="isolinux/isolinux.bin"; CATALOG="isolinux/boot.cat"; }
          [ -f "$WORK/boot/grub/efi.img" ] && EFI_IMG="boot/grub/efi.img"
          [ -z "$EFI_IMG" ] && [ -f "$WORK/EFI/BOOT/efiboot.img" ] && EFI_IMG="EFI/BOOT/efiboot.img"
          [ -z "$EFI_IMG" ] && [ -f "$WORK/efi.img" ] && EFI_IMG="efi.img"
          LABEL_RAW="ECHO_INST_${D}_$(date -u +%Y%m%d)"
          LABEL="$(echo "$LABEL_RAW" | tr -cd 'A-Za-z0-9_-' | cut -c1-16)"; [ -z "$LABEL" ] && LABEL="ECHO_${D}_$(date -u +%y%m%d)"
          OUT="$ISO_DIR/custom_installer_${D}.iso"
          if [ -n "$BIOS_IMG" ] && [ -n "$EFI_IMG" ]; then
            tryrun "xorriso -as mkisofs -r -V '$LABEL' -o '$OUT' -J -l ${CATALOG:+-c '$CATALOG'} -b '$BIOS_IMG' -no-emul-boot -boot-load-size 4 -boot-info-table -eltorito-alt-boot -e '$EFI_IMG' -no-emul-boot -isohybrid-gpt-basdat '$WORK'"
          elif [ -n "$BIOS_IMG" ]; then
            tryrun "xorriso -as mkisofs -r -V '$LABEL' -o '$OUT' -J -l ${CATALOG:+-c '$CATALOG'} -b '$BIOS_IMG' -no-emul-boot -boot-load-size 4 -boot-info-table '$WORK'"
          elif [ -n "$EFI_IMG" ]; then
            tryrun "xorriso -as mkisofs -r -V '$LABEL' -o '$OUT' -J -l -e '$EFI_IMG' -no-emul-boot -isohybrid-gpt-basdat '$WORK'"
          else
            softfail "Boot images not found"
          fi
          [ -f "$OUT" ] && sha256sum "$OUT" | tee "$META_DIR/custom_installer.sha256.txt" >/dev/null || softfail "custom installer ISO missing"

      - name: Post-ISO:extra bulk & MOVE data
        continue-on-error: true
        shell: bash
        run: |
          set -Eeuo pipefail
          source "$ECHO_ROOT/echo_tools.sh"
          EXTRA="$ECHO_ROOT/after_iso_payload"
          mkdir -p "$EXTRA/bulk_extra"
          for i in $(seq 1 50); do
            tryrun "mkdir -p '$EXTRA/bulk_extra/extra_${i}/subA' '$EXTRA/bulk_extra/extra_${i}/subB'"
            echo "extra payload $i" > "$EXTRA/bulk_extra/extra_${i}/README.txt" || true
          done
          if [ -d "$ECHO_ROOT/linux/bulk" ]; then
            mkdir -p "$EXTRA/bulk_from_linux"
            find "$ECHO_ROOT/linux/bulk" -mindepth 1 -maxdepth 1 -type d -print0 | xargs -0 -I{} mv "{}" "$EXTRA/bulk_from_linux"/ || softfail "move linux bulk failed"
          fi
          if [ -d "$ECHO_ROOT/rhel/bulk" ]; then
            mkdir -p "$EXTRA/bulk_from_rhel"
            find "$ECHO_ROOT/rhel/bulk" -mindepth 1 -maxdepth 1 -type d -print0 | xargs -0 -I{} mv "{}" "$EXTRA/bulk_from_rhel"/ || softfail "move rhel bulk failed"
          fi
          tryrun "tar -C '$EXTRA' -cf '$DIST_DIR/after_iso_payload.tar' ."
          echoe "Moved/extended payload -> $DIST_DIR/after_iso_payload.tar"

      - name: Create QCOW2 base & snapshot (backing OK)
        continue-on-error: true
        shell: bash
        run: |
          set -Eeuo pipefail
          source "$ECHO_ROOT/echo_tools.sh"
          ensure_cmd qemu-img
          SIZE_GB="${{ inputs.qcow_size_gb || github.event.inputs.qcow_size_gb }}"
          DISTRO="${{ inputs.distro || github.event.inputs.distro }}"
          META_ABS="$GITHUB_WORKSPACE/${META_DIR}"
          LOG_ABS="$GITHUB_WORKSPACE/${LOG_DIR}"
          IMG_ABS="$GITHUB_WORKSPACE/${IMG_DIR}"
          mkdir -p "$IMG_ABS" "$META_ABS" "$LOG_ABS"
          cd "$IMG_ABS"
          BASE="base_${DISTRO}.qcow2"
          SNAP="snap_${DISTRO}.qcow2"
          echoe "Creating base QCOW2: $BASE (${SIZE_GB}G)"
          tryrun "qemu-img create -f qcow2 -o cluster_size=65536,compression_type=zlib '$BASE' '${SIZE_GB}G'"
          [ -f "$BASE" ] && qemu-img info --output=json "$BASE" | tee "$META_ABS/qcow2_base.info.json" >/dev/null || softfail "base qcow2 missing"
          tryrun "qemu-img check '$BASE' | tee '$LOG_ABS/qcow2_base.check.log'"
          echoe "Creating snapshot with proper relative backing"
          [ -f "$BASE" ] && tryrun "qemu-img create -f qcow2 -b '$BASE' -F qcow2 '$SNAP'" || softfail "snapshot create skipped"
          [ -f "$SNAP" ] && qemu-img info --output=json "$SNAP" | tee "$META_ABS/qcow2_snap.info.json" >/dev/null || softfail "snap qcow2 missing"
          tryrun "qemu-img check '$SNAP' | tee '$LOG_ABS/qcow2_snap.check.log'"

      - name: SBOM (SPDX-JSON)
        continue-on-error: true
        shell: bash
        run: |
          set -Eeuo pipefail
          source "$ECHO_ROOT/echo_tools.sh"
          ensure_cmd syft
          mkdir -p "$DIST_DIR/sbom"
          syft version || softfail "syft version failed"
          tryrun "syft dir:'$DIST_DIR' -o spdx-json > '$DIST_DIR/sbom/dist.spdx.json'"
          [ -s "$DIST_DIR/sbom/dist.spdx.json" ] || softfail "SBOM empty or missing"

      - name: Hash catalog & index
        continue-on-error: true
        shell: bash
        run: |
          set -Eeuo pipefail
          source "$ECHO_ROOT/echo_tools.sh"
          ensure_cmd jq
          HASH_JSON="$META_DIR/hash_index.json"
          : > "$HASH_JSON"
          echo "[" >> "$HASH_JSON"
          first=1
          while IFS= read -r -d '' f; do
            sha256=$(sha256sum "$f" | awk '{print $1}')
            sha512=$(sha512sum "$f" | awk '{print $1}')
            size=$(stat -c%s "$f")
            rel="${f#dist/}"
            entry=$(jq -n --arg path "$rel" --arg sha256 "$sha256" --arg sha512 "$sha512" --argjson size "$size" \
                      '{path:$path,sha256:$sha256,sha512:$sha512,size:$size}')
            if [ $first -eq 1 ]; then echo "  $entry" >> "$HASH_JSON"; first=0; else echo " ,$entry" >> "$HASH_JSON"; fi
          done < <(find dist -type f -print0)
          echo "]" >> "$HASH_JSON"
          echoe "Hash index -> $HASH_JSON"

      - name: 🔧 Start test server (serve dist/) & health check
        continue-on-error: true
        shell: bash
        run: |
          set -Eeuo pipefail
          source "$ECHO_ROOT/echo_tools.sh"
          LOG="$LOG_DIR/test_server.log"
          PORT=8080
          notify "Starting test server on http://127.0.0.1:${PORT} (dist/)"
          ( python3 -m http.server "$PORT" --directory "$DIST_DIR" > "$LOG" 2>&1 & echo $! > "$LOG_DIR/test_server.pid" )
          sleep 2
          tryrun "curl -sSf http://127.0.0.1:${PORT}/ | head -n 5"
          echoe "Test server log saved -> $LOG"

      - name: GHCR upload via ORAS (dynamic files)
        continue-on-error: true
        env:
          ORAS_TAG: ${{ github.run_id }}
          GH_USER: ${{ github.actor }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -Eeuo pipefail
          source "$ECHO_ROOT/echo_tools.sh"
          ensure_cmd oras
          echo "$GH_TOKEN" | oras login ghcr.io -u "$GH_USER" --password-stdin || { softfail "oras login failed"; exit 0; }
          BASE_LC="$(echo "${GHCR_BASE}" | tr '[:upper:]' '[:lower:]')"
          REF="${BASE_LC}:${ORAS_TAG}"
          echoe "ORAS REF: $REF"

          # 동적으로 존재하는 파일만 수집
          declare -a files=()
          while IFS= read -r -d '' f; do files+=("$f"); done < <(find "$ISO_DIR" "$IMG_DIR" "$DIST_DIR/sbom" "$META_DIR" -type f -print0 2>/dev/null || true)
          # 중요 산출물도 개별 체크
          for f in \
            "$DIST_DIR/echo_bulk.tar" \
            "$DIST_DIR/after_iso_payload.tar"; do
            [ -f "$f" ] && files+=("$f")
          done

          if [ ${#files[@]} -eq 0 ]; then
            softfail "No files to push to ORAS"
            exit 0
          fi

          # oras args 구성
          args=(push "$REF" --artifact-type application/vnd.echo.bundle)
          for f in "${files[@]}"; do
            mt="application/octet-stream"
            case "$f" in
              *.json) mt="application/json" ;;
              *.spdx.json) mt="application/spdx+json" ;;
              *.txt|*.log) mt="text/plain" ;;
              *.tar) mt="application/x-tar" ;;
              *.iso) mt="application/octet-stream" ;;
              *.qcow2) mt="application/octet-stream" ;;
            esac
            args+=("$f:$mt")
          done

          echoe "Pushing ${#files[@]} files via ORAS"
          tryrun "${args[@]}"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        continue-on-error: true
        with:
          name: linux-rhel-image-suite-${{ github.run_id }}
          path: |
            dist/**
          if-no-files-found: warn
          retention-days: 7

      - name: Create GitHub Release (tolerant)
        uses: softprops/action-gh-release@v2
        continue-on-error: true
        with:
          tag_name: ${{ inputs.release_tag && inputs.release_tag != '' && inputs.release_tag || format('auto-{0}', github.run_id) }}
          name: "Linux/RHEL Image Suite • ${{ inputs.distro || github.event.inputs.distro }}"
          body: |
            ALL-IN-ONE image suite with GPG, FULL bootable installer ISO, Cloud-Init/Kickstart/Preseed, QCOW2, SBOM, GHCR, hash index, and test server.
            - Distro: `${{ inputs.distro || github.event.inputs.distro }}`
            - Base ISO URL: (see dist/meta/base_iso.urls.json)
            - Custom payload ISO: `dist/isos/custom_payload.iso`
            - FULL installer ISO: `dist/isos/custom_installer_${{ inputs.distro || github.event.inputs.distro }}.iso`
            - Seed ISO (CIDATA): `dist/isos/seed-cidata.iso`
            - QCOW2: `dist/images/base_${{ inputs.distro || github.event.inputs.distro }}.qcow2` + `snap_${{ inputs.distro || github.event.inputs.distro }}.qcow2`
            - SBOM: `dist/sbom/dist.spdx.json`
            - Hash index: `dist/meta/hash_index.json`
            - GHCR ref: `${{ env.GHCR_BASE }}:${{ github.run_id }}`
          files: |
            dist/isos/*.iso
            dist/images/*.qcow2
            dist/meta/**
            dist/logs/**
            dist/sbom/**
            dist/echo_bulk.tar
            dist/after_iso_payload.tar
          fail_on_unmatched_files: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
