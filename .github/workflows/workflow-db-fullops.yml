name: "🗄️ Workflow DB FullOps (ALL++: 대량/권한/가상계정+TLS+Service DB+ISO+Release)"

on:
  schedule:
    - cron: "*/20 * * * *"   # 20분 주기
  workflow_dispatch:
    inputs:
      wf_product:
        description: "워크플로우 제품"
        type: choice
        required: true
        default: "airflow"
        options: ["airflow", "n8n", "ibm-baw", "sharepoint-wfm"]
      target_db:
        description: "대상 DB (all: 모두 실행)"
        type: choice
        required: true
        default: "all"
        options: ["postgres", "mysql", "mssql", "all"]
      db_name:
        description: "DB 이름(기준 접두)"
        required: true
        default: "appdb"
      db_user:
        description: "DB 접속 사용자(기준 접두)"
        required: true
        default: "appuser"
      db_password:
        description: "DB 접속 비밀번호(비워두면 시크릿 우선)"
        required: true
        default: "StrongPw123!"
      grant_model:
        description: "권한 모델"
        type: choice
        required: true
        default: "strict"
        options: ["strict", "basic"]
      run_apply:
        description: "컨테이너 기동 후 실제 적용(지원: postgres/mysql/mssql/all)"
        type: choice
        required: true
        default: "true"
        options: ["true", "false"]
      release_tag:
        description: "릴리즈 태그(예: v1.0.0 또는 AUTO)"
        required: true
        default: "AUTO"
      mode_preset:
        description: "모드 프리셋(full/iso-only/artifacts-only/release-only/minimal)"
        type: choice
        required: true
        default: "full"
        options: ["full","iso-only","artifacts-only","release-only","minimal"]
      extra_json:
        description: "추가설정 JSON(cred_export, enc_mode[aes|zip|none], enc_pass, iso_enable, bulk_count 등)"
        required: false
        default: "{}"

permissions:
  contents: write

concurrency:
  group: db-fullops-${{ github.ref }}-${{ github.workflow }}
  cancel-in-progress: true

jobs:
  db-fullops:
    runs-on: ubuntu-latest
    timeout-minutes: 60

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Cleanup old containers (idempotent)
        shell: bash
        run: |
          set -Eeuo pipefail
          for n in pg mysqldb mssql; do
            if docker ps -a --format '{{.Names}}' | grep -qx "$n"; then
              docker rm -f "$n" || true
            fi
          done

      - name: System upgrade & base tools
        shell: bash
        run: |
          set -Eeuo pipefail
          sudo apt-get update
          sudo DEBIAN_FRONTEND=noninteractive apt-get -y upgrade
          sudo apt-get -y install jq rsync gettext-base genisoimage openssl zip

      - name: Prepare variables & dirs
        id: prep
        shell: bash
        run: |
          set -Eeuo pipefail
          echo "WF_PRODUCT=${{ github.event.inputs.wf_product }}" >> $GITHUB_ENV
          echo "TARGET_DB=${{ github.event.inputs.target_db }}" >> $GITHUB_ENV
          echo "DB_NAME=${{ github.event.inputs.db_name }}" >> $GITHUB_ENV
          echo "DB_USER=${{ github.event.inputs.db_user }}" >> $GITHUB_ENV
          echo "DB_PASSWORD=${{ github.event.inputs.db_password }}" >> $GITHUB_ENV
          echo "GRANT_MODEL=${{ github.event.inputs.grant_model }}" >> $GITHUB_ENV
          echo "RUN_APPLY=${{ github.event.inputs.run_apply }}" >> $GITHUB_ENV

          MODE="${{ github.event.inputs.mode_preset }}"
          case "$MODE" in
            full)          ISO_ENABLE=true; ISO_PER_SERVICE=true; CREATE_ARTIFACTS=true; RELEASE_ENABLE=true;  RELEASE_PRERELEASE=false; ENABLE_TLS=true;;
            iso-only)      ISO_ENABLE=true; ISO_PER_SERVICE=true; CREATE_ARTIFACTS=true; RELEASE_ENABLE=false; RELEASE_PRERELEASE=false; ENABLE_TLS=true;;
            artifacts-only)ISO_ENABLE=false;ISO_PER_SERVICE=false;CREATE_ARTIFACTS=true; RELEASE_ENABLE=false; RELEASE_PRERELEASE=false; ENABLE_TLS=true;;
            release-only)  ISO_ENABLE=false;ISO_PER_SERVICE=false;CREATE_ARTIFACTS=false;RELEASE_ENABLE=true;  RELEASE_PRERELEASE=false; ENABLE_TLS=true;;
            minimal|*)     ISO_ENABLE=false;ISO_PER_SERVICE=false;CREATE_ARTIFACTS=false;RELEASE_ENABLE=false; RELEASE_PRERELEASE=false; ENABLE_TLS=false;;
          esac

          # 기본 대량 설정 + extra_json 오버라이드
          BULK_COUNT=30
          BULK_PREFIX="${{ github.event.inputs.db_user }}_bulk"
          ISO_BULK_DIR_COUNT=30
          ISO_BULK_DIR_PREFIX="bundle_"
          CRED_EXPORT=true
          ENC_MODE="none"     # none|aes|zip
          ENC_PASS=""         # 있으면 사용(권장: 시크릿)
          EXTRA='${{ github.event.inputs.extra_json }}'

          parse_bool() { v="$1"; [ "$v" = "true" ] && echo true || [ "$v" = "false" ] && echo false || echo ""; }
          if [ -n "$EXTRA" ] && [ "$EXTRA" != "null" ]; then
            jq -e . >/dev/null 2>&1 <<<"$EXTRA" || { echo "extra_json JSON 오류"; exit 1; }
            v=$(jq -r 'select(.iso_enable!=null)        | .iso_enable'            <<<"$EXTRA"); b=$(parse_bool "$v"); [ -n "$b" ] && ISO_ENABLE=$b
            v=$(jq -r 'select(.iso_per_service!=null)   | .iso_per_service'        <<<"$EXTRA"); b=$(parse_bool "$v"); [ -n "$b" ] && ISO_PER_SERVICE=$b
            v=$(jq -r 'select(.create_artifacts!=null)  | .create_artifacts'       <<<"$EXTRA"); b=$(parse_bool "$v"); [ -n "$b" ] && CREATE_ARTIFACTS=$b
            v=$(jq -r 'select(.enable_tls!=null)        | .enable_tls'             <<<"$EXTRA"); b=$(parse_bool "$v"); [ -n "$b" ] && ENABLE_TLS=$b
            v=$(jq -r 'select(.release_enable!=null)    | .release_enable'         <<<"$EXTRA"); b=$(parse_bool "$v"); [ -n "$b" ] && RELEASE_ENABLE=$b
            v=$(jq -r 'select(.release_prerelease!=null)| .release_prerelease'     <<<"$EXTRA"); b=$(parse_bool "$v"); [ -n "$b" ] && RELEASE_PRERELEASE=$b
            v=$(jq -r 'select(.bulk_count!=null)         | .bulk_count'            <<<"$EXTRA"); [ "$v" != "null" ] && [ -n "$v" ] && BULK_COUNT="$v"
            v=$(jq -r 'select(.bulk_prefix!=null)        | .bulk_prefix'           <<<"$EXTRA"); [ "$v" != "null" ] && [ -n "$v" ] && BULK_PREFIX="$v"
            v=$(jq -r 'select(.iso_bulk_dir_count!=null) | .iso_bulk_dir_count'    <<<"$EXTRA"); [ "$v" != "null" ] && [ -n "$v" ] && ISO_BULK_DIR_COUNT="$v"
            v=$(jq -r 'select(.iso_bulk_dir_prefix!=null)| .iso_bulk_dir_prefix'   <<<"$EXTRA"); [ "$v" != "null" ] && [ -n "$v" ] && ISO_BULK_DIR_PREFIX="$v"
            v=$(jq -r 'select(.cred_export!=null)        | .cred_export'           <<<"$EXTRA"); b=$(parse_bool "$v"); [ -n "$b" ] && CRED_EXPORT=$b
            v=$(jq -r 'select(.enc_mode!=null)           | .enc_mode'              <<<"$EXTRA"); [ "$v" != "null" ] && [ -n "$v" ] && ENC_MODE="$v"
            v=$(jq -r 'select(.enc_pass!=null)           | .enc_pass'              <<<"$EXTRA"); [ "$v" != "null" ] && [ -n "$v" ] && ENC_PASS="$v"
          fi

          # 시크릿 우선 암호/패스
          [ -n "${{ secrets.DB_PASSWORD }}" ] && echo "DB_PASSWORD=${{ secrets.DB_PASSWORD }}" >> $GITHUB_ENV
          [ -n "${{ secrets.CRED_ENC_PASS }}" ] && ENC_PASS="${{ secrets.CRED_ENC_PASS }}"

          echo "ENABLE_TLS=${ENABLE_TLS}"                 >> $GITHUB_ENV
          echo "CREATE_ARTIFACTS=${CREATE_ARTIFACTS}"     >> $GITHUB_ENV
          echo "ISO_ENABLE=${ISO_ENABLE}"                 >> $GITHUB_ENV
          echo "ISO_PER_SERVICE=${ISO_PER_SERVICE}"       >> $GITHUB_ENV
          echo "RELEASE_ENABLE=${RELEASE_ENABLE}"         >> $GITHUB_ENV
          echo "RELEASE_PRERELEASE=${RELEASE_PRERELEASE}" >> $GITHUB_ENV
          echo "BULK_COUNT=${BULK_COUNT}"                 >> $GITHUB_ENV
          echo "BULK_PREFIX=${BULK_PREFIX}"               >> $GITHUB_ENV
          echo "ISO_BULK_DIR_COUNT=${ISO_BULK_DIR_COUNT}" >> $GITHUB_ENV
          echo "ISO_BULK_DIR_PREFIX=${ISO_BULK_DIR_PREFIX}" >> $GITHUB_ENV
          echo "CRED_EXPORT=${CRED_EXPORT}"               >> $GITHUB_ENV
          echo "ENC_MODE=${ENC_MODE}"                     >> $GITHUB_ENV
          [ -n "$ENC_PASS" ] && echo "ENC_PASS=SET" >> $GITHUB_ENV || echo "ENC_PASS=" >> $GITHUB_ENV

          if [ -z "${{ github.event.inputs.release_tag }}" ] || [ "${{ github.event.inputs.release_tag }}" = "AUTO" ]; then
            REL_TAG="vAUTO-${GITHUB_RUN_NUMBER}"
          else
            REL_TAG="${{ github.event.inputs.release_tag }}"
          fi
          echo "RELEASE_TAG=${REL_TAG}" >> $GITHUB_ENV
          echo "MSSQL_SA_PASSWORD=Str0ng!Passw0rd" >> $GITHUB_ENV

          mkdir -p \
            .github/echo_db/{postgres,mysql,mssql,oracle,db2,common} \
            .github/echo_products/{airflow,n8n,ibm-baw,sharepoint-wfm} \
            .github/echo_ansible/{group_vars,roles/db_tasks/{templates,tasks}} \
            .github/out/{release_root,iso} \
            .github/echo_tls \
            .github/echo_docs \
            .github/secure/creds

          # 기본 .gitignore / 문서
          cat > .github/echo_docs/README.md <<'MD'
          # Workflow DB FullOps — 대량/가상계정/서비스 전반 반영
          - DB 스크립트/권한/대량 유저/서비스별 DB/유저 자동화
          - TLS 자산/ISO/릴리즈/암호화된 자격증명 아티팩트
          - extra_json으로 세부 제어(cred_export, enc_mode[aes|zip|none], enc_pass 등)
          MD
          cat > .gitignore <<'GI'
          .github/out/
          .github/secure/
          GI

      - name: (Optional) Generate self-signed TLS assets
        if: ${{ env.ENABLE_TLS == 'true' }}
        shell: bash
        run: |
          set -Eeuo pipefail
          TLS_DIR=".github/echo_tls"
          cd "$TLS_DIR"
          openssl genrsa -out ca.key 4096
          openssl req -x509 -new -nodes -key ca.key -sha256 -days 3650 -subj "/CN=FullOps-Local-CA" -out ca.crt
          openssl genrsa -out server.key 4096
          cat > san.cnf <<'CNF'
          [req]
          distinguished_name=req
          req_extensions = v3_req
          [v3_req]
          subjectAltName = @alt_names
          [alt_names]
          DNS.1 = localhost
          DNS.2 = db.example.com
          IP.1 = 127.0.0.1
          CNF
          openssl req -new -key server.key -subj "/CN=db.example.com" -out server.csr -config san.cnf
          openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt -days 825 -sha256 -extensions v3_req -extfile san.cnf
          chmod 600 server.key

      - name: Generate service DB users (Airflow/n8n/BAW/SharePoint)
        shell: bash
        run: |
          set -Eeuo pipefail
          # 로그에 비번 노출 금지
          set +x
          mkpw(){ openssl rand -base64 18 | tr -d '\n'; }
          # 제품별 DB/유저/패스워드
          for svc in airflow n8n ibm_baw sp_wfm; do
            SVC_DB="${DB_NAME}_${svc}"
            SVC_USER="${DB_USER}_${svc}"
            SVC_PW="$(mkpw)"
            echo "::add-mask::$SVC_PW"
            printf "%s,%s,%s\n" "$svc" "$SVC_USER" "$SVC_PW" >> .github/secure/creds/services.csv

            # Postgres
            cat >> .github/echo_db/postgres/20_service.sql <<SQL
          DO \$\$
          BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_database WHERE datname='${SVC_DB}') THEN PERFORM dblink_exec('dbname=postgres','CREATE DATABASE ${SVC_DB}'); END IF;
          EXCEPTION WHEN undefined_function THEN
            -- dblink 없으면 스킵(컨테이너 적용 단계에서 DB 생성 루프로 대체)
          END\$\$;
          DO \$\$
          BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname='${SVC_USER}') THEN
              EXECUTE format('CREATE ROLE %I LOGIN PASSWORD %L', '${SVC_USER}', '${SVC_PW}');
            END IF;
          END\$\$;
          SQL

            # MySQL
            cat >> .github/echo_db/mysql/20_service.sql <<SQL
          CREATE DATABASE IF NOT EXISTS \`${SVC_DB}\` CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;
          CREATE USER IF NOT EXISTS '${SVC_USER}'@'%' IDENTIFIED BY '${SVC_PW}';
          GRANT ALL ON \`${SVC_DB}\`.* TO '${SVC_USER}'@'%';
          FLUSH PRIVILEGES;
          SQL

            # MSSQL
            cat >> .github/echo_db/mssql/20_service.sql <<SQL
          IF DB_ID(N'${SVC_DB}') IS NULL CREATE DATABASE [${SVC_DB}];
          IF NOT EXISTS (SELECT 1 FROM sys.sql_logins WHERE name = N'${SVC_USER}')
            CREATE LOGIN [${SVC_USER}] WITH PASSWORD=N'${SVC_PW}', CHECK_POLICY=ON;
          USE [${SVC_DB}];
          IF NOT EXISTS (SELECT 1 FROM sys.database_principals WHERE name = N'${SVC_USER}')
            CREATE USER [${SVC_USER}] FOR LOGIN [${SVC_USER}];
          EXEC sp_addrolemember N'db_owner', N'${SVC_USER}';
          SQL
          done
          set -x

      - name: Generate BULK SQL (baseline)
        shell: bash
        run: |
          set -Eeuo pipefail
          # 기존(공통) 모델 파일 생성 - (이전 워크플로우의 01~03, 99_bulk 등 동일/생략분 포함)
          # 여기서는 99_bulk(고정 비번 방식)만 간단히 생성하고, 아래에서 "고유 비번" 버전(98_bulk_creds)을 생성합니다.

          # --- Postgres 99_bulk (고정 비번) ---
          {
            echo "/* BULK users/grants for PostgreSQL (fixed password fallback) */"
            cat <<'EOS'
          DO $$
          BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname='app_read') THEN CREATE ROLE app_read NOLOGIN; END IF;
            IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname='app_write') THEN CREATE ROLE app_write NOLOGIN; END IF;
          END$$;
          EOS
            for i in $(seq -w 1 ${BULK_COUNT}); do
              uname="${BULK_PREFIX}${i}"
              db="${DB_NAME}_${i}"
              cat <<EOS
          DO \$\$
          BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname='${uname}') THEN
              EXECUTE format('CREATE ROLE %I LOGIN PASSWORD %L', '${uname}', '${DB_PASSWORD}');
            END IF;
          END\$\$;
          \\connect "${db}"
          ALTER SCHEMA public OWNER TO "${uname}";
          GRANT app_read  TO "${uname}";
          GRANT app_write TO "${uname}";
          EOS
            done
          } > .github/echo_db/postgres/99_bulk.sql

          # --- MySQL 99_bulk ---
          {
            echo "/* BULK (fixed password) for MySQL */"
            for i in $(seq -w 1 ${BULK_COUNT}); do
              uname="${BULK_PREFIX}${i}"
              db="${DB_NAME}_${i}"
              cat <<EOS
          CREATE DATABASE IF NOT EXISTS \`${db}\` CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;
          CREATE USER IF NOT EXISTS '${uname}'@'%' IDENTIFIED BY '${DB_PASSWORD}';
          GRANT SELECT,INSERT,UPDATE,DELETE ON \`${db}\`.* TO '${uname}'@'%';
          FLUSH PRIVILEGES;
          EOS
            done
          } > .github/echo_db/mysql/99_bulk.sql

          # --- MSSQL 99_bulk ---
          cat > .github/echo_db/mssql/99_bulk.sql <<SQL
          DECLARE @i INT = 1;
          WHILE @i <= ${BULK_COUNT}
          BEGIN
            DECLARE @uname SYSNAME = CONCAT('${BULK_PREFIX}', RIGHT(CONCAT('0', @i), 2));
            DECLARE @db SYSNAME = CONCAT('${DB_NAME}_', RIGHT(CONCAT('0', @i), 2));
            IF DB_ID(@db) IS NULL EXEC('CREATE DATABASE [' + @db + '];');
            IF NOT EXISTS (SELECT 1 FROM sys.sql_logins WHERE name=@uname)
              EXEC('CREATE LOGIN [' + @uname + '] WITH PASSWORD=N''${DB_PASSWORD}'', CHECK_POLICY=ON;');
            SET @i += 1;
          END
          GO
          SQL

      - name: Generate VIRTUAL credentials & per-tenant SQL (unique passwords)
        shell: bash
        run: |
          set -Eeuo pipefail
          set +x
          mkpw(){ openssl rand -base64 18 | tr -d '\n'; }
          # CSV 헤더
          echo "dbms,tenant,username,password,database" > .github/secure/creds/tenants.csv

          # Postgres per-tenant unique
          {
            echo "/* BULK(users) with unique passwords for PostgreSQL */"
            cat <<'EOS'
          DO $$
          BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname='app_read') THEN CREATE ROLE app_read NOLOGIN; END IF;
            IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname='app_write') THEN CREATE ROLE app_write NOLOGIN; END IF;
          END$$;
          EOS
            for i in $(seq -w 1 ${BULK_COUNT}); do
              uname="${BULK_PREFIX}${i}"
              db="${DB_NAME}_${i}"
              pw="$(mkpw)"
              echo "::add-mask::$pw"
              printf "postgres,%s,%s,%s,%s\n" "$i" "$uname" "$pw" "$db" >> .github/secure/creds/tenants.csv
              cat <<EOS
          DO \$\$
          BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname='${uname}') THEN
              EXECUTE format('CREATE ROLE %I LOGIN PASSWORD %L', '${uname}', '${pw}');
            END IF;
          END\$\$;
          \\connect "${db}"
          ALTER SCHEMA public OWNER TO "${uname}";
          GRANT app_read  TO "${uname}";
          GRANT app_write TO "${uname}";
          \\connect postgres
          EOS
            done
          } > .github/echo_db/postgres/98_bulk_creds.sql

          # MySQL per-tenant unique
          {
            echo "/* BULK(unique passwords) for MySQL */"
            for i in $(seq -w 1 ${BULK_COUNT}); do
              uname="${BULK_PREFIX}${i}"
              db="${DB_NAME}_${i}"
              pw="$(mkpw)"
              echo "::add-mask::$pw"
              printf "mysql,%s,%s,%s,%s\n" "$i" "$uname" "$pw" "$db" >> .github/secure/creds/tenants.csv
              cat <<EOS
          CREATE DATABASE IF NOT EXISTS \`${db}\` CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;
          CREATE USER IF NOT EXISTS '${uname}'@'%' IDENTIFIED BY '${pw}';
          GRANT SELECT,INSERT,UPDATE,DELETE ON \`${db}\`.* TO '${uname}'@'%';
          FLUSH PRIVILEGES;
          EOS
            done
          } > .github/echo_db/mysql/98_bulk_creds.sql

          # MSSQL per-tenant unique
          {
            echo "/* BULK(unique passwords) for MSSQL */"
            cat <<EOS
          DECLARE @i INT = 1;
          WHILE @i <= ${BULK_COUNT}
          BEGIN
            DECLARE @uname SYSNAME;
            DECLARE @db SYSNAME;
            -- 개별 SQL 블록은 아래 bash 루프에서 채움
          END
          GO
          EOS
          } > .github/echo_db/mssql/98_bulk_creds.sql

          # mssql은 루프 안에서 별도 append(비번 치환)
          for i in $(seq -w 1 ${BULK_COUNT}); do
            uname="${BULK_PREFIX}${i}"
            db="${DB_NAME}_${i}"
            pw="$(mkpw)"
            echo "::add-mask::$pw"
            printf "mssql,%s,%s,%s,%s\n" "$i" "$uname" "$pw" "$db" >> .github/secure/creds/tenants.csv
            cat >> .github/echo_db/mssql/98_bulk_creds.sql <<SQL
          IF DB_ID(N'${db}') IS NULL EXEC('CREATE DATABASE [${db}]');
          IF NOT EXISTS (SELECT 1 FROM sys.sql_logins WHERE name = N'${uname}')
            EXEC('CREATE LOGIN [${uname}] WITH PASSWORD=N''${pw}'', CHECK_POLICY=ON;');
          SQL
          done
          set -x

      - name: Build release trees (ALL/POSTGRES/MYSQL/MSSQL)
        if: ${{ env.ISO_ENABLE == 'true' }}
        shell: bash
        run: |
          set -Eeuo pipefail
          ROOT=".github/out/release_root"
          mkdir -p "$ROOT/ALL"
          mkdir -p \
            "$ROOT/POSTGRES/echo_db/postgres" "$ROOT/POSTGRES/echo_db/common" \
            "$ROOT/MYSQL/echo_db/mysql"       "$ROOT/MYSQL/echo_db/common" \
            "$ROOT/MSSQL/echo_db/mssql"       "$ROOT/MSSQL/echo_db/common"
          rsync -a .github/echo_db/       "$ROOT/ALL/echo_db/"
          rsync -a .github/echo_products/ "$ROOT/ALL/echo_products/"
          rsync -a .github/echo_ansible/  "$ROOT/ALL/echo_ansible/"
          [ -d .github/echo_tls ] && rsync -a .github/echo_tls/ "$ROOT/ALL/echo_tls/" || true
          for i in $(seq -w 1 ${ISO_BULK_DIR_COUNT}); do
            mkdir -p "$ROOT/ALL/${ISO_BULK_DIR_PREFIX}${i}"
            echo "placeholder ${i}" > "$ROOT/ALL/${ISO_BULK_DIR_PREFIX}${i}/README.txt"
          done
          rsync -a .github/echo_db/postgres/ "$ROOT/POSTGRES/echo_db/postgres/"
          rsync -a .github/echo_db/common/   "$ROOT/POSTGRES/echo_db/common/"
          rsync -a .github/echo_db/mysql/    "$ROOT/MYSQL/echo_db/mysql/"
          rsync -a .github/echo_db/common/   "$ROOT/MYSQL/echo_db/common/"
          rsync -a .github/echo_db/mssql/    "$ROOT/MSSQL/echo_db/mssql/"
          rsync -a .github/echo_db/common/   "$ROOT/MSSQL/echo_db/common/"

      - name: Make ISOs
        if: ${{ env.ISO_ENABLE == 'true' }}
        shell: bash
        run: |
          set -Eeuo pipefail
          OUT=".github/out/iso"
          ROOT=".github/out/release_root"
          TS="$(date -u +%Y%m%dT%H%M%SZ)"
          mkdir -p "$OUT"
          genisoimage -quiet -J -r -V "FULLOPS_ALL" -o "$OUT/FULLOPS_ALL_${TS}.iso" "$ROOT/ALL"
          if [ "${ISO_PER_SERVICE}" = "true" ]; then
            genisoimage -quiet -J -r -V "FULLOPS_POSTGRES" -o "$OUT/FULLOPS_POSTGRES_${TS}.iso" "$ROOT/POSTGRES"
            genisoimage -quiet -J -r -V "FULLOPS_MYSQL"    -o "$OUT/FULLOPS_MYSQL_${TS}.iso"    "$ROOT/MYSQL"
            genisoimage -quiet -J -r -V "FULLOPS_MSSQL"    -o "$OUT/FULLOPS_MSSQL_${TS}.iso"    "$ROOT/MSSQL"
          fi
          (cd "$OUT" && sha256sum *.iso > CHECKSUMS.txt)
          echo "ISO_TIME=${TS}" >> $GITHUB_ENV

      - name: Start PostgreSQL container
        if: ${{ env.RUN_APPLY == 'true' && (env.TARGET_DB == 'postgres' || env.TARGET_DB == 'all') }}
        shell: bash
        run: |
          set -Eeuo pipefail
          docker run -d --name pg -e POSTGRES_PASSWORD=postgres -p 5432:5432 \
            --health-cmd="pg_isready -U postgres || exit 1" --health-interval=5s --health-retries=20 postgres:16
          for i in {1..40}; do
            if docker exec pg pg_isready -U postgres >/dev/null 2>&1; then break; fi
            sleep 3
          done
          docker exec pg pg_isready -U postgres
          # 서비스/테넌트용 DB 선생성
          for i in $(seq -w 1 ${BULK_COUNT}); do docker exec -u postgres pg createdb "${DB_NAME}_${i}" || true; done
          for svc in airflow n8n ibm_baw sp_wfm; do docker exec -u postgres pg createdb "${DB_NAME}_${svc}" || true; done

      - name: Start MySQL container
        if: ${{ env.RUN_APPLY == 'true' && (env.TARGET_DB == 'mysql' || env.TARGET_DB == 'all') }}
        shell: bash
        run: |
          set -Eeuo pipefail
          docker run -d --name mysqldb -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 \
            --health-cmd="mysqladmin ping -h 127.0.0.1 -proot || exit 1" --health-interval=5s --health-retries=24 mysql:8
          sudo apt-get update && sudo apt-get install -y mysql-client
          mkdir -p .github/secure
          cat > .github/secure/mysql.cnf <<'CNF'
          [client]
          host=127.0.0.1
          user=root
          password=root
          port=3306
          CNF
          chmod 600 .github/secure/mysql.cnf
          for i in {1..60}; do
            if mysqladmin --defaults-extra-file=.github/secure/mysql.cnf ping --silent >/dev/null 2>&1; then break; fi
            sleep 3
          done

      - name: Install MSSQL client & Start container
        if: ${{ env.RUN_APPLY == 'true' && (env.TARGET_DB == 'mssql' || env.TARGET_DB == 'all') }}
        shell: bash
        run: |
          set -Eeuo pipefail
          sudo apt-get update
          sudo apt-get install -y curl ca-certificates gnupg apt-transport-https
          curl -fsSL https://packages.microsoft.com/keys/microsoft.asc | sudo gpg --dearmor -o /usr/share/keyrings/microsoft.gpg
          echo "deb [arch=amd64 signed-by=/usr/share/keyrings/microsoft.gpg] https://packages.microsoft.com/ubuntu/22.04/prod jammy main" | sudo tee /etc/apt/sources.list.d/mssql-release.list
          sudo apt-get update || (sleep 5 && sudo apt-get update)
          sudo ACCEPT_EULA=Y apt-get install -y msodbcsql18 mssql-tools18
          export PATH="$PATH:/opt/mssql-tools18/bin"
          docker run -d --name mssql -e "ACCEPT_EULA=Y" -e "MSSQL_SA_PASSWORD=${MSSQL_SA_PASSWORD}" -p 1433:1433 \
            --health-cmd="/opt/mssql-tools18/bin/sqlcmd -S localhost -U sa -C -Q 'SELECT 1' || exit 1" \
            --health-interval=5s --health-retries=24 mcr.microsoft.com/mssql/server:2022-latest
          for i in {1..80}; do
            if docker exec -e SQLCMDPASSWORD="${MSSQL_SA_PASSWORD}" mssql /opt/mssql-tools18/bin/sqlcmd -S localhost -U sa -C -Q "SELECT 1" >/dev/null 2>&1; then break; fi
            sleep 3
          done || true

      - name: Apply SQL (PostgreSQL:base + services + bulk-unique pref)
        if: ${{ env.RUN_APPLY == 'true' && (env.TARGET_DB == 'postgres' || env.TARGET_DB == 'all') }}
        shell: bash
        run: |
          set -Eeuo pipefail
          sudo apt-get update && sudo apt-get install -y postgresql-client gettext-base
          umask 077
          printf "127.0.0.1:5432:*:postgres:postgres\n" > ~/.pgpass
          # 기본 유저/권한/모델
          envsubst < .github/echo_db/postgres/01_roles.sql         | psql -h 127.0.0.1 -U postgres -d "${DB_NAME}" -v ON_ERROR_STOP=1
          envsubst < .github/echo_db/postgres/02_schema_grants.sql | psql -h 127.0.0.1 -U postgres -d "${DB_NAME}" -v ON_ERROR_STOP=1
          if [ "${GRANT_MODEL}" = "strict" ]; then
            psql -h 127.0.0.1 -U postgres -d "${DB_NAME}" -v ON_ERROR_STOP=1 -f .github/echo_db/postgres/03_model_strict.sql
          else
            psql -h 127.0.0.1 -U postgres -d "${DB_NAME}" -v ON_ERROR_STOP=1 -f .github/echo_db/postgres/03_model_basic.sql
          fi
          # 서비스 전용
          [ -f .github/echo_db/postgres/20_service.sql ] && envsubst < .github/echo_db/postgres/20_service.sql | psql -h 127.0.0.1 -U postgres -d postgres -v ON_ERROR_STOP=1 || true
          # 대량 유저(고유 비번 우선, 없으면 고정 비번)
          if [ -s .github/echo_db/postgres/98_bulk_creds.sql ]; then
            envsubst < .github/echo_db/postgres/98_bulk_creds.sql | psql -h 127.0.0.1 -U postgres -d postgres -v ON_ERROR_STOP=1
          else
            envsubst < .github/echo_db/postgres/99_bulk.sql       | psql -h 127.0.0.1 -U postgres -d postgres -v ON_ERROR_STOP=1
          fi

      - name: Apply SQL (MySQL:base + services + bulk-unique pref)
        if: ${{ env.RUN_APPLY == 'true' && (env.TARGET_DB == 'mysql' || env.TARGET_DB == 'all') }}
        shell: bash
        run: |
          set -Eeuo pipefail
          sudo apt-get update && sudo apt-get install -y mysql-client gettext-base
          for i in {1..20}; do
            if mysql --defaults-extra-file=.github/secure/mysql.cnf -e "SELECT 1" >/dev/null 2>&1; then break; fi
            sleep 3
          done
          envsubst < .github/echo_db/mysql/00_create_db.sql | mysql --defaults-extra-file=.github/secure/mysql.cnf
          envsubst < .github/echo_db/mysql/01_user.sql      | mysql --defaults-extra-file=.github/secure/mysql.cnf
          if [ "${GRANT_MODEL}" = "strict" ]; then
            envsubst < .github/echo_db/mysql/02_grants_strict.sql | mysql --defaults-extra-file=.github/secure/mysql.cnf
          else
            envsubst < .github/echo_db/mysql/02_grants_basic.sql  | mysql --defaults-extra-file=.github/secure/mysql.cnf
          fi
          [ -f .github/echo_db/mysql/20_service.sql ] && envsubst < .github/echo_db/mysql/20_service.sql | mysql --defaults-extra-file=.github/secure/mysql.cnf || true
          if [ -s .github/echo_db/mysql/98_bulk_creds.sql ]; then
            envsubst < .github/echo_db/mysql/98_bulk_creds.sql | mysql --defaults-extra-file=.github/secure/mysql.cnf
          else
            envsubst < .github/echo_db/mysql/99_bulk.sql       | mysql --defaults-extra-file=.github/secure/mysql.cnf
          fi
          shred -u .github/secure/mysql.cnf || rm -f .github/secure/mysql.cnf

      - name: Apply SQL (MSSQL:base + services + bulk-unique pref)
        if: ${{ env.RUN_APPLY == 'true' && (env.TARGET_DB == 'mssql' || env.TARGET_DB == 'all') }}
        shell: bash
        run: |
          set -Eeuo pipefail
          export PATH="$PATH:/opt/mssql-tools18/bin"
          export SQLCMDPASSWORD="${MSSQL_SA_PASSWORD}"
          envsubst < .github/echo_db/mssql/00_create_db.sql        | sqlcmd -S 127.0.0.1 -U sa -C
          envsubst < .github/echo_db/mssql/01_roles.sql            | sqlcmd -S 127.0.0.1 -U sa -C
          envsubst < .github/echo_db/mssql/02_user_and_grants.sql  | sqlcmd -S 127.0.0.1 -U sa -C
          [ "${GRANT_MODEL}" = "strict" ] && envsubst < .github/echo_db/mssql/03_model_strict.sql | sqlcmd -S 127.0.0.1 -U sa -C || true
          [ "${GRANT_MODEL}" != "strict" ] && envsubst < .github/echo_db/mssql/03_model_basic.sql | sqlcmd -S 127.0.0.1 -U sa -C || true
          [ -f .github/echo_db/mssql/20_service.sql ] && envsubst < .github/echo_db/mssql/20_service.sql | sqlcmd -S 127.0.0.1 -U sa -C || true
          if [ -s .github/echo_db/mssql/98_bulk_creds.sql ]; then
            envsubst < .github/echo_db/mssql/98_bulk_creds.sql | sqlcmd -S 127.0.0.1 -U sa -C
          else
            envsubst < .github/echo_db/mssql/99_bulk.sql       | sqlcmd -S 127.0.0.1 -U sa -C
          fi

      - name: Package & (optional) encrypt credentials bundle
        if: ${{ env.CREATE_ARTIFACTS == 'true' && env.CRED_EXPORT == 'true' }}
        shell: bash
        run: |
          set -Eeuo pipefail
          cd .github/secure
          tar czf credentials.tar.gz creds
          # ENC_MODE: none|zip|aes
          if [ "${ENC_MODE}" = "zip" ] && [ "${ENC_PASS}" = "SET" ]; then
            rm -f credentials.zip
            # zip -P는 강력하지 않으므로 운영은 AES 권장
            zip -j -q -P "${{ secrets.CRED_ENC_PASS }}" credentials.zip credentials.tar.gz
            rm -f credentials.tar.gz
          elif [ "${ENC_MODE}" = "aes" ] && [ "${ENC_PASS}" = "SET" ]; then
            openssl enc -aes-256-cbc -salt -pbkdf2 -in credentials.tar.gz -out credentials.tar.gz.enc -pass env:CRED_PASS
            rm -f credentials.tar.gz
          fi

        env:
          CRED_PASS: ${{ secrets.CRED_ENC_PASS }}

      - name: Upload artifacts (scripts/samples/ansible/tls/credentials)
        if: ${{ env.CREATE_ARTIFACTS == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: db-fullops-artifacts
          path: |
            .github/echo_db/**
            .github/echo_products/**
            .github/echo_ansible/**
            .github/echo_tls/**
            .github/echo_docs/**
            .github/secure/credentials.*
            .github/secure/credentials.tar.gz.enc

      - name: Upload ISO images
        if: ${{ env.ISO_ENABLE == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: iso-images
          path: .github/out/iso/*

      - name: Create GitHub Release (tag & upload ISOs)
        if: ${{ env.RELEASE_ENABLE == 'true' && env.ISO_ENABLE == 'true' }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.RELEASE_TAG }}
          name: "Workflow DB FullOps ${{ env.RELEASE_TAG }}"
          body: |
            Workflow DB FullOps 대량 확장 릴리즈
            - 제품: ${{ env.WF_PRODUCT }}
            - 대상 DB: ${{ env.TARGET_DB }}
            - 권한 모델: ${{ env.GRANT_MODEL }}
            - ISO 타임스탬프: ${{ env.ISO_TIME }}
            - 포함: Scripts/Service DB/TLS/Oracle-Db2 템플릿 + ISO + (선택)자격증명 번들
          draft: false
          prerelease: ${{ env.RELEASE_PRERELEASE == 'true' }}
          files: |
            .github/out/iso/*.iso
            .github/out/iso/CHECKSUMS.txt
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
