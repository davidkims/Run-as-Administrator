name: "🗄️ Workflow DB FullOps (ALL: 권한/대량+적용+TLS+Oracle/Db2+Ansible/Makefile+ISO+Release)"

on:
  workflow_dispatch:
    inputs:
      wf_product:
        description: "워크플로우 제품"
        type: choice
        required: true
        default: "airflow"
        options: ["airflow", "n8n", "ibm-baw", "sharepoint-wfm"]

      target_db:
        description: "대상 DB (all: 모두 실행)"
        type: choice
        required: true
        default: "all"
        options: ["postgres", "mysql", "mssql", "all"]

      db_name:
        description: "DB 이름(기준 접두)"
        required: true
        default: "appdb"

      db_user:
        description: "DB 접속 사용자(기준 접두)"
        required: true
        default: "appuser"

      db_password:
        description: "DB 접속 비밀번호"
        required: true
        default: "StrongPw123!"

      grant_model:
        description: "권한 모델"
        type: choice
        required: true
        default: "strict"
        options: ["strict", "basic"]

      run_apply:
        description: "컨테이너 기동 후 실제 적용(지원: postgres/mysql/mssql/all)"
        type: choice
        required: true
        default: "true"
        options: ["true", "false"]

      release_tag:
        description: "릴리즈 태그(예: v1.0.0 또는 AUTO)"
        required: true
        default: "AUTO"

      mode_preset:
        description: "모드 프리셋(full/iso-only/artifacts-only/release-only/minimal)"
        type: choice
        required: true
        default: "full"
        options: ["full","iso-only","artifacts-only","release-only","minimal"]

      extra_json:
        description: "추가설정 JSON(선택) — iso_enable, iso_per_service, create_artifacts, enable_tls, bulk_count, bulk_prefix, iso_bulk_dir_count, iso_bulk_dir_prefix, release_enable, release_prerelease"
        required: false
        default: "{}"

permissions:
  contents: write

jobs:
  db-fullops:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: System upgrade (apt-get)
        shell: bash
        run: |
          set -Eeuo pipefail
          sudo apt-get update
          sudo DEBIAN_FRONTEND=noninteractive apt-get -y upgrade
          sudo apt-get -y install gettext-base jq rsync

      - name: Prepare variables & dirs
        id: prep
        shell: bash
        run: |
          set -Eeuo pipefail
          echo "WF_PRODUCT=${{ github.event.inputs.wf_product }}" >> $GITHUB_ENV
          echo "TARGET_DB=${{ github.event.inputs.target_db }}" >> $GITHUB_ENV
          echo "DB_NAME=${{ github.event.inputs.db_name }}" >> $GITHUB_ENV
          echo "DB_USER=${{ github.event.inputs.db_user }}" >> $GITHUB_ENV
          echo "DB_PASSWORD=${{ github.event.inputs.db_password }}" >> $GITHUB_ENV
          echo "GRANT_MODEL=${{ github.event.inputs.grant_model }}" >> $GITHUB_ENV
          echo "RUN_APPLY=${{ github.event.inputs.run_apply }}" >> $GITHUB_ENV

          # ===== 프리셋 기본값 =====
          MODE="${{ github.event.inputs.mode_preset }}"
          case "$MODE" in
            full)
              ISO_ENABLE=true; ISO_PER_SERVICE=true; CREATE_ARTIFACTS=true; RELEASE_ENABLE=true; RELEASE_PRERELEASE=false; ENABLE_TLS=true;;
            iso-only)
              ISO_ENABLE=true; ISO_PER_SERVICE=true; CREATE_ARTIFACTS=true; RELEASE_ENABLE=false; RELEASE_PRERELEASE=false; ENABLE_TLS=true;;
            artifacts-only)
              ISO_ENABLE=false; ISO_PER_SERVICE=false; CREATE_ARTIFACTS=true; RELEASE_ENABLE=false; RELEASE_PRERELEASE=false; ENABLE_TLS=true;;
            release-only)
              ISO_ENABLE=false; ISO_PER_SERVICE=false; CREATE_ARTIFACTS=false; RELEASE_ENABLE=true; RELEASE_PRERELEASE=false; ENABLE_TLS=true;;
            minimal|*)
              ISO_ENABLE=false; ISO_PER_SERVICE=false; CREATE_ARTIFACTS=false; RELEASE_ENABLE=false; RELEASE_PRERELEASE=false; ENABLE_TLS=false;;
          esac

          # ===== 기본 수치/접두 =====
          BULK_COUNT=20
          BULK_PREFIX="${{ github.event.inputs.db_user }}_bulk"
          ISO_BULK_DIR_COUNT=20
          ISO_BULK_DIR_PREFIX="bundle_"

          # ===== extra_json 오버라이드 =====
          EXTRA='${{ github.event.inputs.extra_json }}'
          parse_bool() { v="$1"; [ "$v" = "true" ] && echo true || [ "$v" = "false" ] && echo false || echo ""; }
          if [ -n "$EXTRA" ] && [ "$EXTRA" != "null" ]; then
            jq -e . >/dev/null 2>&1 <<<"$EXTRA" || { echo "extra_json이 올바른 JSON이 아닙니다"; exit 1; }

            v=$(jq -r 'select(.iso_enable!=null)     | .iso_enable'            <<<"$EXTRA"); b=$(parse_bool "$v"); [ -n "$b" ] && ISO_ENABLE=$b
            v=$(jq -r 'select(.iso_per_service!=null)| .iso_per_service'        <<<"$EXTRA"); b=$(parse_bool "$v"); [ -n "$b" ] && ISO_PER_SERVICE=$b
            v=$(jq -r 'select(.create_artifacts!=null)| .create_artifacts'      <<<"$EXTRA"); b=$(parse_bool "$v"); [ -n "$b" ] && CREATE_ARTIFACTS=$b
            v=$(jq -r 'select(.enable_tls!=null)     | .enable_tls'             <<<"$EXTRA"); b=$(parse_bool "$v"); [ -n "$b" ] && ENABLE_TLS=$b
            v=$(jq -r 'select(.release_enable!=null) | .release_enable'         <<<"$EXTRA"); b=$(parse_bool "$v"); [ -n "$b" ] && RELEASE_ENABLE=$b
            v=$(jq -r 'select(.release_prerelease!=null)| .release_prerelease'  <<<"$EXTRA"); b=$(parse_bool "$v"); [ -n "$b" ] && RELEASE_PRERELEASE=$b

            v=$(jq -r 'select(.bulk_count!=null)         | .bulk_count'         <<<"$EXTRA"); [ "$v" != "null" ] && [ -n "$v" ] && BULK_COUNT="$v"
            v=$(jq -r 'select(.bulk_prefix!=null)        | .bulk_prefix'        <<<"$EXTRA"); [ "$v" != "null" ] && [ -n "$v" ] && BULK_PREFIX="$v"
            v=$(jq -r 'select(.iso_bulk_dir_count!=null) | .iso_bulk_dir_count' <<<"$EXTRA"); [ "$v" != "null" ] && [ -n "$v" ] && ISO_BULK_DIR_COUNT="$v"
            v=$(jq -r 'select(.iso_bulk_dir_prefix!=null)| .iso_bulk_dir_prefix'<<<"$EXTRA"); [ "$v" != "null" ] && [ -n "$v" ] && ISO_BULK_DIR_PREFIX="$v"
          fi

          echo "ENABLE_TLS=${ENABLE_TLS}"                 >> $GITHUB_ENV
          echo "CREATE_ARTIFACTS=${CREATE_ARTIFACTS}"     >> $GITHUB_ENV
          echo "ISO_ENABLE=${ISO_ENABLE}"                 >> $GITHUB_ENV
          echo "ISO_PER_SERVICE=${ISO_PER_SERVICE}"       >> $GITHUB_ENV
          echo "RELEASE_ENABLE=${RELEASE_ENABLE}"         >> $GITHUB_ENV
          echo "RELEASE_PRERELEASE=${RELEASE_PRERELEASE}" >> $GITHUB_ENV
          echo "BULK_COUNT=${BULK_COUNT}"                 >> $GITHUB_ENV
          echo "BULK_PREFIX=${BULK_PREFIX}"               >> $GITHUB_ENV
          echo "ISO_BULK_DIR_COUNT=${ISO_BULK_DIR_COUNT}" >> $GITHUB_ENV
          echo "ISO_BULK_DIR_PREFIX=${ISO_BULK_DIR_PREFIX}" >> $GITHUB_ENV

          # 릴리즈 태그 계산
          if [ -z "${{ github.event.inputs.release_tag }}" ] || [ "${{ github.event.inputs.release_tag }}" = "AUTO" ]; then
            REL_TAG="vAUTO-${GITHUB_RUN_NUMBER}"
          else
            REL_TAG="${{ github.event.inputs.release_tag }}"
          fi
          echo "RELEASE_TAG=${REL_TAG}" >> $GITHUB_ENV

          # 비밀 기본값
          echo "MSSQL_SA_PASSWORD=Str0ng!Passw0rd" >> $GITHUB_ENV

          mkdir -p \
            .github/echo_db/{postgres,mysql,mssql,oracle,db2,common} \
            .github/echo_products/{airflow,n8n,ibm-baw,sharepoint-wfm} \
            .github/echo_ansible/group_vars \
            .github/echo_ansible/roles/db_tasks/{templates,tasks} \
            .github/out/release_root \
            .github/out/iso

      # 공통 가이드/TLS(문서)
      - name: Generate common guides & TLS templates
        shell: bash
        run: |
          set -Eeuo pipefail
          cat > .github/echo_db/common/SECURITY_TLS_GUIDE.md <<'MD'
          # 보안/TLS 요약
          - TLS 강제(서버 인증서), 최소권한(ROLE/GRANT), 비밀관리(Vault/KeyVault)
          - 감사 로깅/로테이션, 백업/DR(PITR/스냅샷), 정기 복구 리허설
          MD
          cat > .github/echo_db/common/BACKUP_DR_CHECKLIST.md <<'MD'
          # 백업/DR 체크리스트
          - 전체/증분, RPO/RTO, DR Runbook
          - 레플리카/클러스터(AG/Patroni/InnoDB Cluster 등) + 모니터링/알람
          MD
          cat > .github/echo_db/mssql/TLS_CLIENT_CONNECTION_EXAMPLES.md <<'MD'
          ## MSSQL TLS 클라이언트 연결 예시
          - sqlcmd(ODBC 18+): sqlcmd -S host,1433 -U user -C -Q "SELECT 1"
          - JDBC: jdbc:sqlserver://host:1433;databaseName=appdb;encrypt=true;trustServerCertificate=false;hostNameInCertificate=CN=db.example.com;
          - ODBC: Encrypt=Yes;TrustServerCertificate=No;HostNameInCertificate=CN=db.example.com;
          MD
          cat > .github/echo_db/mssql/TLS_SERVER_ENABLE_GUIDE.md <<'MD'
          # MSSQL TLS 서버 활성화 개요
          1) CA 인증서 준비(FQDN 포함) 2) SQL Server에 등록/바인딩 3) force encryption=on
          4) 클라이언트: encrypt=true, trustServerCertificate=false, hostNameInCertificate 일치
          * 컨테이너는 커스텀 이미지 + 인증서 바인딩 스크립트 필요
          MD

      # 제품별 샘플
      - name: Generate product samples
        shell: bash
        run: |
          set -Eeuo pipefail
          cat > .github/echo_products/airflow/ENV.sample <<'ENV'
          AIRFLOW__DATABASE__SQL_ALCHEMY_CONN=postgresql+psycopg2://airflow:pw@db:5432/airflow
          # airflow db init && airflow webserver
          ENV
          cat > .github/echo_products/n8n/ENV.sample <<'ENV'
          DB_TYPE=postgresdb
          DB_POSTGRESDB_HOST=db
          DB_POSTGRESDB_PORT=5432
          DB_POSTGRESDB_DATABASE=n8n
          DB_POSTGRESDB_USER=n8n
          DB_POSTGRESDB_PASSWORD=strong_pw
          ENV
          cat > .github/echo_products/ibm-baw/JDBC.sample.properties <<'PROPS'
          db.type=postgres
          db.url=jdbc:postgresql://db.example.com:5432/bawdb?sslmode=require
          db.user=baw
          db.password=*****
          # BAW: Process/PDW/Common DB 분리(단, Postgres는 Common DB 제외)
          PROPS
          cat > .github/echo_products/sharepoint-wfm/SETUP_CHECKLIST.md <<'MD'
          - SQL Server: TCP/IP(1433) 활성, SQL Browser 실행
          - Azure Service Fabric Runtime 설치
          - 팜 구성 계정/권한, 방화벽 예외
          MD

      # Ansible/Makefile 스캐폴딩
      - name: Generate Ansible skeleton & Makefile
        shell: bash
        run: |
          set -Eeuo pipefail
          cat > .github/echo_ansible/inventory.ini <<'INV'
          [db_local]
          127.0.0.1 ansible_connection=local
          INV
          cat > .github/echo_ansible/group_vars/all.yml <<YML
          db_name: ${DB_NAME}
          db_user: ${DB_USER}
          db_password: ${DB_PASSWORD}
          grant_model: ${GRANT_MODEL}
          target_db: ${TARGET_DB}
          YML
          cat > .github/echo_ansible/roles/db_tasks/tasks/main.yml <<'YML'
          ---
          - name: Show DB variables
            debug:
              msg:
                db_name: "{{ db_name }}"
                db_user: "{{ db_user }}"
                grant_model: "{{ grant_model }}"
                target_db: "{{ target_db }}"
          - name: Display note
            debug:
              msg: "로컬 생성된 SQL 템플릿을 배포/적용하는 골격 예시입니다."
          YML
          cat > .github/echo_ansible/site.yml <<'YML'
          ---
          - hosts: db_local
            gather_facts: false
            roles:
              - db_tasks
          YML
          cat > .github/echo_ansible/Makefile <<'MK'
          .PHONY: ansible-setup ansible-run show
          ansible-setup:
          	python3 -m pip install --upgrade pip
          	pip3 install ansible
          ansible-run:
          	ansible-playbook -i inventory.ini site.yml
          show:
          	@echo "DB: ${DB_NAME}, USER: ${DB_USER}, MODEL: ${GRANT_MODEL}, TARGET: ${TARGET_DB}"
          MK

      # Postgres SQL 생성(권한/대량)
      - name: Generate PostgreSQL SQL (roles/grants + bulk)
        shell: bash
        run: |
          set -Eeuo pipefail
          cat > .github/echo_db/postgres/01_roles.sql <<'SQL'
          DO $$
          BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname='${DB_USER}') THEN
              EXECUTE format('CREATE ROLE %I LOGIN PASSWORD %L', '${DB_USER}', '${DB_PASSWORD}');
            END IF;
          END$$;
          DO $$
          BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname='app_read') THEN CREATE ROLE app_read NOLOGIN; END IF;
            IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname='app_write') THEN CREATE ROLE app_write NOLOGIN; END IF;
          END$$;
          GRANT app_read TO "${DB_USER}";
          GRANT app_write TO "${DB_USER}";
          SQL
          cat > .github/echo_db/postgres/02_schema_grants.sql <<'SQL'
          ALTER SCHEMA public OWNER TO "${DB_USER}";
          -- CREATE SCHEMA IF NOT EXISTS "${EXTRA_SCHEMA}" AUTHORIZATION "${DB_USER}";
          ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT ON TABLES TO app_read;
          ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT,INSERT,UPDATE,DELETE ON TABLES TO app_write;
          SQL
          cat > .github/echo_db/postgres/03_model_strict.sql <<'SQL'
          CREATE TABLE IF NOT EXISTS public.process_instance(
            id BIGSERIAL PRIMARY KEY,
            status TEXT NOT NULL,
            assignee TEXT,
            created_at TIMESTAMPTZ DEFAULT now()
          );
          REVOKE ALL ON public.process_instance FROM PUBLIC;
          GRANT SELECT ON public.process_instance TO app_read;
          GRANT SELECT,INSERT,UPDATE,DELETE ON public.process_instance TO app_write;
          SQL
          cat > .github/echo_db/postgres/03_model_basic.sql <<'SQL'
          GRANT USAGE ON SCHEMA public TO app_read, app_write;
          GRANT SELECT ON ALL TABLES IN SCHEMA public TO app_read;
          GRANT SELECT,INSERT,UPDATE,DELETE ON ALL TABLES IN SCHEMA public TO app_write;
          SQL
          {
            echo "/* BULK users/grants for PostgreSQL (DB must exist) */"
            cat <<'EOS'
          DO $$
          BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname='app_read') THEN CREATE ROLE app_read NOLOGIN; END IF;
            IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname='app_write') THEN CREATE ROLE app_write NOLOGIN; END IF;
          END$$;
          EOS
            for i in $(seq -w 1 ${BULK_COUNT}); do
              uname="${BULK_PREFIX}${i}"
              db="${DB_NAME}_${i}"
              cat <<EOS
          -- user/db ${i}
          DO \$\$
          BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname='${uname}') THEN
              EXECUTE format('CREATE ROLE %I LOGIN PASSWORD %L', '${uname}', '${DB_PASSWORD}');
            END IF;
          END\$\$;

          \\connect "${db}"

          ALTER SCHEMA public OWNER TO "${uname}";
          GRANT app_read  TO "${uname}";
          GRANT app_write TO "${uname}";
          ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT ON TABLES TO app_read;
          ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT,INSERT,UPDATE,DELETE ON TABLES TO app_write;

          CREATE TABLE IF NOT EXISTS public.process_instance(
            id BIGSERIAL PRIMARY KEY,
            status TEXT NOT NULL,
            assignee TEXT,
            created_at TIMESTAMPTZ DEFAULT now()
          );
          REVOKE ALL ON public.process_instance FROM PUBLIC;
          GRANT SELECT ON public.process_instance TO app_read;
          GRANT SELECT,INSERT,UPDATE,DELETE ON public.process_instance TO app_write;

          \\connect postgres
          EOS
            done
          } > .github/echo_db/postgres/99_bulk.sql

      # MySQL SQL 생성(권한/대량)
      - name: Generate MySQL SQL (create/user/grants + bulk)
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p .github/echo_db/mysql
          cat > .github/echo_db/mysql/00_create_db.sql <<'SQL'
          CREATE DATABASE IF NOT EXISTS `${DB_NAME}` CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;
          SQL
          cat > .github/echo_db/mysql/01_user.sql <<'SQL'
          CREATE USER IF NOT EXISTS '${DB_USER}'@'%' IDENTIFIED BY '${DB_PASSWORD}';
          GRANT USAGE ON *.* TO '${DB_USER}'@'%';
          SQL
          cat > .github/echo_db/mysql/02_grants_basic.sql <<'SQL'
          GRANT SELECT ON `${DB_NAME}`.* TO '${DB_USER}'@'%';
          GRANT INSERT, UPDATE, DELETE ON `${DB_NAME}`.* TO '${DB_USER}'@'%';
          FLUSH PRIVILEGES;
          SQL
          cat > .github/echo_db/mysql/02_grants_strict.sql <<'SQL'
          USE `${DB_NAME}`;
          CREATE TABLE IF NOT EXISTS process_instance(
            id BIGINT PRIMARY KEY AUTO_INCREMENT,
            status VARCHAR(64) NOT NULL,
            assignee VARCHAR(128),
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
          );
          REVOKE ALL PRIVILEGES, GRANT OPTION FROM '${DB_USER}'@'%';
          GRANT SELECT ON `${DB_NAME}`.process_instance TO '${DB_USER}'@'%';
          GRANT INSERT,UPDATE,DELETE ON `${DB_NAME}`.process_instance TO '${DB_USER}'@'%';
          FLUSH PRIVILEGES;
          SQL
          {
            echo "/* BULK CREATE (users/db) for MySQL */"
            for i in $(seq -w 1 ${BULK_COUNT}); do
              uname="${BULK_PREFIX}${i}"
              db="${DB_NAME}_${i}"
              cat <<EOS
          CREATE DATABASE IF NOT EXISTS \`${db}\` CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;
          CREATE USER IF NOT EXISTS '${uname}'@'%' IDENTIFIED BY '${DB_PASSWORD}';
          GRANT SELECT,INSERT,UPDATE,DELETE ON \`${db}\`.* TO '${uname}'@'%';
          FLUSH PRIVILEGES;
          EOS
            done
          } > .github/echo_db/mysql/99_bulk.sql

      # MSSQL SQL 생성(권한/대량)
      - name: Generate MSSQL SQL (roles/grants + bulk)
        shell: bash
        run: |
          set -Eeuo pipefail
          cat > .github/echo_db/mssql/00_create_db.sql <<'SQL'
          IF DB_ID(N'${DB_NAME}') IS NULL
            CREATE DATABASE [${DB_NAME}];
          GO
          SQL
          cat > .github/echo_db/mssql/01_roles.sql <<'SQL'
          USE [${DB_NAME}];
          IF NOT EXISTS (SELECT 1 FROM sys.database_principals WHERE name=N'app_read')  CREATE ROLE app_read  AUTHORIZATION dbo;
          IF NOT EXISTS (SELECT 1 FROM sys.database_principals WHERE name=N'app_write') CREATE ROLE app_write AUTHORIZATION dbo;
          SQL
          cat > .github/echo_db/mssql/02_user_and_grants.sql <<'SQL'
          USE [${DB_NAME}];
          IF NOT EXISTS (SELECT 1 FROM sys.sql_logins WHERE name = N'${DB_USER}')
            CREATE LOGIN [${DB_USER}] WITH PASSWORD=N'${DB_PASSWORD}', CHECK_POLICY=ON;
          IF NOT EXISTS (SELECT 1 FROM sys.database_principals WHERE name = N'${DB_USER}')
            CREATE USER [${DB_USER}] FOR LOGIN [${DB_USER}];
          EXEC sp_addrolemember N'app_read',  N'${DB_USER}';
          EXEC sp_addrolemember N'app_write', N'${DB_USER}';
          SQL
          cat > .github/echo_db/mssql/03_model_strict.sql <<'SQL'
          USE [${DB_NAME}];
          IF OBJECT_ID('dbo.process_instance','U') IS NULL
            CREATE TABLE dbo.process_instance(
              id BIGINT IDENTITY(1,1) PRIMARY KEY,
              status NVARCHAR(64) NOT NULL,
              assignee NVARCHAR(128),
              created_at DATETIME2 DEFAULT SYSUTCDATETIME()
            );
          DENY SELECT, INSERT, UPDATE, DELETE ON dbo.process_instance TO PUBLIC;
          GRANT SELECT ON dbo.process_instance TO app_read;
          GRANT SELECT, INSERT, UPDATE, DELETE ON dbo.process_instance TO app_write;
          SQL
          cat > .github/echo_db/mssql/03_model_basic.sql <<'SQL'
          USE [${DB_NAME}];
          EXEC sp_addrolemember N'app_read',  N'${DB_USER}';
          EXEC sp_addrolemember N'app_write', N'${DB_USER}';
          SQL
          cat > .github/echo_db/mssql/99_bulk.sql <<'SQL'
          DECLARE @i INT = 1;
          WHILE @i <= ${BULK_COUNT}
          BEGIN
            DECLARE @uname SYSNAME = CONCAT('${BULK_PREFIX}', RIGHT(CONCAT('0', @i), 2));
            DECLARE @db SYSNAME = CONCAT('${DB_NAME}_', RIGHT(CONCAT('0', @i), 2));
            IF DB_ID(@db) IS NULL
              EXEC('CREATE DATABASE [' + @db + '];');
            IF NOT EXISTS (SELECT 1 FROM sys.sql_logins WHERE name=@uname)
              EXEC('CREATE LOGIN [' + @uname + '] WITH PASSWORD=N''${DB_PASSWORD}'', CHECK_POLICY=ON;');
            DECLARE @sql NVARCHAR(MAX) = N'USE [' + @db + ']; ' +
              N'IF NOT EXISTS (SELECT 1 FROM sys.database_principals WHERE name=N''app_read'')  CREATE ROLE app_read AUTHORIZATION dbo; ' +
              N'IF NOT EXISTS (SELECT 1 FROM sys.database_principals WHERE name=N''app_write'') CREATE ROLE app_write AUTHORIZATION dbo; ' +
              N'IF NOT EXISTS (SELECT 1 FROM sys.database_principals WHERE name=N''' + @uname + ''') CREATE USER [' + @uname + '] FOR LOGIN [' + @uname + ']; ' +
              N'EXEC sp_addrolemember N''app_read'',  N''' + @uname + N'''; ' +
              N'EXEC sp_addrolemember N''app_write'', N''' + @uname + N'''; ';
            EXEC sp_executesql @sql;
            SET @i += 1;
          END
          GO
          SQL

      # Oracle/Db2 템플릿
      - name: Generate Oracle/Db2 templates
        shell: bash
        run: |
          set -Eeuo pipefail
          cat > .github/echo_db/oracle/create_user.sql <<'SQL'
          -- sqlplus sys/*****@//host:1521/ORCLPDB1 as sysdba
          CREATE USER ${DB_USER} IDENTIFIED BY "${DB_PASSWORD}"
            DEFAULT TABLESPACE USERS TEMPORARY TABLESPACE TEMP QUOTA UNLIMITED ON USERS;
          GRANT CREATE SESSION TO ${DB_USER};
          GRANT CONNECT, RESOURCE TO ${DB_USER};
          SQL
          cat > .github/echo_db/oracle/grants_basic.sql <<'SQL'
          GRANT SELECT, INSERT, UPDATE, DELETE ON ${DB_USER}.PROCESS_INSTANCE TO ${DB_USER};
          SQL
          cat > .github/echo_db/db2/create_user.sql <<'SQL'
          -- db2 connect to ${DB_NAME} user db2inst1 using ******
          GRANT CONNECT ON DATABASE TO USER ${DB_USER};
          GRANT CREATETAB ON DATABASE TO USER ${DB_USER};
          SQL

      # 릴리즈 트리 & ISO
      - name: Build release trees (bulk directories) & common README
        if: ${{ env.ISO_ENABLE == 'true' }}
        shell: bash
        run: |
          set -Eeuo pipefail
          ROOT=".github/out/release_root"
          mkdir -p "$ROOT/ALL"
          rsync -a .github/echo_db/        "$ROOT/ALL/echo_db/"
          rsync -a .github/echo_products/  "$ROOT/ALL/echo_products/"
          rsync -a .github/echo_ansible/   "$ROOT/ALL/echo_ansible/"
          mkdir -p "$ROOT/POSTGRES" "$ROOT/MYSQL" "$ROOT/MSSQL"
          rsync -a .github/echo_db/postgres/ "$ROOT/POSTGRES/echo_db/postgres/"
          rsync -a .github/echo_db/common/   "$ROOT/POSTGRES/echo_db/common/"
          rsync -a .github/echo_db/mysql/    "$ROOT/MYSQL/echo_db/mysql/"
          rsync -a .github/echo_db/common/   "$ROOT/MYSQL/echo_db/common/"
          rsync -a .github/echo_db/mssql/    "$ROOT/MSSQL/echo_db/mssql/"
          rsync -a .github/echo_db/common/   "$ROOT/MSSQL/echo_db/common/"
          for i in $(seq -w 1 ${ISO_BULK_DIR_COUNT}); do
            mkdir -p "$ROOT/ALL/${ISO_BULK_DIR_PREFIX}${i}"
            echo "placeholder ${i}" > "$ROOT/ALL/${ISO_BULK_DIR_PREFIX}${i}/README.txt"
          done
          cat > "$ROOT/ALL/README_FULLOPS.txt" <<TXT
          이 ISO에는 DB 스크립트(권한/대량), TLS 가이드, 제품별 샘플설정, Ansible/Makefile 템플릿이 포함되어 있습니다.
          TXT

      - name: Make ISOs (ALL + per service)
        if: ${{ env.ISO_ENABLE == 'true' }}
        shell: bash
        run: |
          set -Eeuo pipefail
          sudo apt-get update && sudo apt-get install -y genisoimage
          OUT=".github/out/iso"
          ROOT=".github/out/release_root"
          TS="$(date -u +%Y%m%dT%H%M%SZ)"
          mkdir -p "$OUT"
          genisoimage -quiet -J -r -V "FULLOPS_ALL" -o "$OUT/FULLOPS_ALL_${TS}.iso" "$ROOT/ALL"
          if [ "${ISO_PER_SERVICE}" = "true" ]; then
            genisoimage -quiet -J -r -V "FULLOPS_POSTGRES" -o "$OUT/FULLOPS_POSTGRES_${TS}.iso" "$ROOT/POSTGRES"
            genisoimage -quiet -J -r -V "FULLOPS_MYSQL"    -o "$OUT/FULLOPS_MYSQL_${TS}.iso"    "$ROOT/MYSQL"
            genisoimage -quiet -J -r -V "FULLOPS_MSSQL"    -o "$OUT/FULLOPS_MSSQL_${TS}.iso"    "$ROOT/MSSQL"
          fi
          (cd "$OUT" && sha256sum *.iso > CHECKSUMS.txt)
          echo "ISO_TIME=${TS}" >> $GITHUB_ENV

      # 컨테이너 기동
      - name: Start PostgreSQL container
        if: ${{ env.RUN_APPLY == 'true' && (env.TARGET_DB == 'postgres' || env.TARGET_DB == 'all') }}
        shell: bash
        run: |
          set -Eeuo pipefail
          docker run -d --name pg -e POSTGRES_PASSWORD=postgres -p 5432:5432 postgres:16
          for i in {1..40}; do
            if docker exec pg pg_isready -U postgres >/dev/null 2>&1; then break; fi
            sleep 3
          done
          docker exec pg pg_isready -U postgres

      - name: Start MySQL container (secure client file)
        if: ${{ env.RUN_APPLY == 'true' && (env.TARGET_DB == 'mysql' || env.TARGET_DB == 'all') }}
        shell: bash
        run: |
          set -Eeuo pipefail
          docker run -d --name mysqldb -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 mysql:8
          sudo apt-get update && sudo apt-get install -y mysql-client
          mkdir -p .github/secure
          cat > .github/secure/mysql.cnf <<'CNF'
          [client]
          host=127.0.0.1
          user=root
          password=root
          port=3306
          # ssl-mode=REQUIRED
          CNF
          chmod 600 .github/secure/mysql.cnf
          for i in {1..60}; do
            if mysqladmin --defaults-extra-file=.github/secure/mysql.cnf ping --silent >/dev/null 2>&1; then break; fi
            sleep 3
          done

      - name: Start MSSQL container
        if: ${{ env.RUN_APPLY == 'true' && (env.TARGET_DB == 'mssql' || env.TARGET_DB == 'all') }}
        shell: bash
        run: |
          set -Eeuo pipefail
          docker run -d --name mssql -e "ACCEPT_EULA=Y" -e "MSSQL_SA_PASSWORD=${MSSQL_SA_PASSWORD}" -p 1433:1433 mcr.microsoft.com/mssql/server:2022-latest
          for i in {1..80}; do
            if docker exec -e SQLCMDPASSWORD="${MSSQL_SA_PASSWORD}" mssql /opt/mssql-tools18/bin/sqlcmd -S localhost -U sa -C -Q "SELECT 1" >/dev/null 2>&1; then break; fi
            sleep 3
          done || true

      # 실제 적용 (비밀번호 경고 제거: pgpass/defaults-extra-file/SQLCMDPASSWORD)
      - name: Apply SQL (PostgreSQL)
        if: ${{ env.RUN_APPLY == 'true' && (env.TARGET_DB == 'postgres' || env.TARGET_DB == 'all') }}
        shell: bash
        run: |
          set -Eeuo pipefail
          sudo apt-get update && sudo apt-get install -y postgresql-client gettext-base
          umask 077
          printf "127.0.0.1:5432:*:postgres:postgres\n" > ~/.pgpass
          if ! psql -h 127.0.0.1 -U postgres -d postgres -tAc "SELECT 1 FROM pg_database WHERE datname='${DB_NAME}'" | grep -q 1; then
            createdb -h 127.0.0.1 -p 5432 -U postgres "${DB_NAME}"
          fi
          envsubst < .github/echo_db/postgres/01_roles.sql         | psql -h 127.0.0.1 -U postgres -d "${DB_NAME}" -v ON_ERROR_STOP=1
          envsubst < .github/echo_db/postgres/02_schema_grants.sql | psql -h 127.0.0.1 -U postgres -d "${DB_NAME}" -v ON_ERROR_STOP=1
          if [ "${GRANT_MODEL}" = "strict" ]; then
            psql -h 127.0.0.1 -U postgres -d "${DB_NAME}" -v ON_ERROR_STOP=1 -f .github/echo_db/postgres/03_model_strict.sql
          else
            psql -h 127.0.0.1 -U postgres -d "${DB_NAME}" -v ON_ERROR_STOP=1 -f .github/echo_db/postgres/03_model_basic.sql
          fi
          for i in $(seq -w 1 ${BULK_COUNT}); do
            db="${DB_NAME}_${i}"
            if ! psql -h 127.0.0.1 -U postgres -d postgres -tAc "SELECT 1 FROM pg_database WHERE datname='${db}'" | grep -q 1; then
              createdb -h 127.0.0.1 -p 5432 -U postgres "${db}"
            fi
          done
          envsubst < .github/echo_db/postgres/99_bulk.sql | psql -h 127.0.0.1 -U postgres -d postgres -v ON_ERROR_STOP=1

      - name: Apply SQL (MySQL) + Bulk
        if: ${{ env.RUN_APPLY == 'true' && (env.TARGET_DB == 'mysql' || env.TARGET_DB == 'all') }}
        shell: bash
        run: |
          set -Eeuo pipefail
          sudo apt-get update && sudo apt-get install -y mysql-client gettext-base
          for i in {1..20}; do
            if mysql --defaults-extra-file=.github/secure/mysql.cnf -e "SELECT 1" >/dev/null 2>&1; then break; fi
            sleep 3
          done
          envsubst < .github/echo_db/mysql/00_create_db.sql | mysql --defaults-extra-file=.github/secure/mysql.cnf
          envsubst < .github/echo_db/mysql/01_user.sql      | mysql --defaults-extra-file=.github/secure/mysql.cnf
          if [ "${GRANT_MODEL}" = "strict" ]; then
            envsubst < .github/echo_db/mysql/02_grants_strict.sql | mysql --defaults-extra-file=.github/secure/mysql.cnf
          else
            envsubst < .github/echo_db/mysql/02_grants_basic.sql  | mysql --defaults-extra-file=.github/secure/mysql.cnf
          fi
          envsubst < .github/echo_db/mysql/99_bulk.sql | mysql --defaults-extra-file=.github/secure/mysql.cnf
          shred -u .github/secure/mysql.cnf || rm -f .github/secure/mysql.cnf

      - name: Apply SQL (MSSQL) + Bulk (sqlcmd)
        if: ${{ env.RUN_APPLY == 'true' && (env.TARGET_DB == 'mssql' || env.TARGET_DB == 'all') }}
        shell: bash
        run: |
          set -Eeuo pipefail
          sudo apt-get update
          sudo apt-get install -y curl ca-certificates apt-transport-https gnupg gettext-base
          curl -sSL https://packages.microsoft.com/keys/microsoft.asc | sudo gpg --dearmor -o /usr/share/keyrings/microsoft.gpg
          echo "deb [arch=amd64 signed-by=/usr/share/keyrings/microsoft.gpg] https://packages.microsoft.com/ubuntu/22.04/prod jammy main" | sudo tee /etc/apt/sources.list.d/mssql-release.list
          sudo apt-get update
          sudo ACCEPT_EULA=Y apt-get install -y msodbcsql18 mssql-tools18
          export PATH="$PATH:/opt/mssql-tools18/bin"
          export SQLCMDPASSWORD="${MSSQL_SA_PASSWORD}"
          for i in {1..60}; do
            if sqlcmd -S 127.0.0.1 -U sa -C -Q "SELECT 1" >/dev/null 2>&1; then break; fi
            sleep 3
          done
          envsubst < .github/echo_db/mssql/00_create_db.sql        | sqlcmd -S 127.0.0.1 -U sa -C
          envsubst < .github/echo_db/mssql/01_roles.sql            | sqlcmd -S 127.0.0.1 -U sa -C
          envsubst < .github/echo_db/mssql/02_user_and_grants.sql  | sqlcmd -S 127.0.0.1 -U sa -C
          if [ "${GRANT_MODEL}" = "strict" ]; then
            envsubst < .github/echo_db/mssql/03_model_strict.sql | sqlcmd -S 127.0.0.1 -U sa -C
          else
            envsubst < .github/echo_db/mssql/03_model_basic.sql  | sqlcmd -S 127.0.0.1 -U sa -C
          fi
          envsubst < .github/echo_db/mssql/99_bulk.sql | sqlcmd -S 127.0.0.1 -U sa -C

      # 산출물 업로드
      - name: Upload artifacts (scripts & samples & ansible)
        if: ${{ env.CREATE_ARTIFACTS == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: db-fullops-artifacts
          path: |
            .github/echo_db/**
            .github/echo_products/**
            .github/echo_ansible/**

      - name: Upload ISO images
        if: ${{ env.ISO_ENABLE == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: iso-images
          path: .github/out/iso/*

      # GitHub Release
      - name: Create GitHub Release (tag & upload ISOs)
        if: ${{ env.RELEASE_ENABLE == 'true' && env.ISO_ENABLE == 'true' }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.RELEASE_TAG }}
          name: "Workflow DB FullOps ${{ env.RELEASE_TAG }}"
          body: |
            Workflow DB FullOps 통합 릴리즈
            - 제품: ${{ env.WF_PRODUCT }}
            - 대상 DB: ${{ env.TARGET_DB }}
            - 권한 모델: ${{ env.GRANT_MODEL }}
            - ISO 타임스탬프: ${{ env.ISO_TIME }}
            - 포함: Scripts/Ansible/TLS/Oracle-Db2 + ISO(ALL${{ env.ISO_PER_SERVICE == 'true' && ' + per-service' || '' }})
          draft: false
          prerelease: ${{ env.RELEASE_PRERELEASE == 'true' }}
          files: |
            .github/out/iso/*.iso
            .github/out/iso/CHECKSUMS.txt
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
